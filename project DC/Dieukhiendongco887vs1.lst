CCS PCM C Compiler, Version 5.015, 5967               28-Nov-14 15:13

               Filename:   N:\Tai Lieu Hoc Tap Nam 4\Vi dieu khien\project\Dieukhiendongco887vs1.lst

               ROM used:   3007 words (37%)
                           Largest free fragment is 2048
               RAM used:   99 (27%) at main() level
                           155 (42%) worst case
               Stack used: 6 locations (3 in main + 3 for interrupts)
               Stack size: 8

*
0000:  MOVLW  09
0001:  MOVWF  0A
0002:  GOTO   187
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  BTFSS  0B.5
0018:  GOTO   01B
0019:  BTFSC  0B.2
001A:  GOTO   038
001B:  MOVLW  8C
001C:  MOVWF  04
001D:  BTFSS  00.5
001E:  GOTO   021
001F:  BTFSC  0C.5
0020:  GOTO   03B
0021:  MOVLW  8D
0022:  MOVWF  04
0023:  BTFSS  00.0
0024:  GOTO   027
0025:  BTFSC  0D.0
0026:  GOTO   03E
0027:  MOVF   22,W
0028:  MOVWF  04
0029:  MOVF   23,W
002A:  MOVWF  77
002B:  MOVF   24,W
002C:  MOVWF  78
002D:  MOVF   25,W
002E:  MOVWF  79
002F:  MOVF   26,W
0030:  MOVWF  7A
0031:  MOVF   20,W
0032:  MOVWF  0A
0033:  SWAPF  21,W
0034:  MOVWF  03
0035:  SWAPF  7F,F
0036:  SWAPF  7F,W
0037:  RETFIE
0038:  BCF    0A.3
0039:  BCF    0A.4
003A:  GOTO   4BD
003B:  BCF    0A.3
003C:  BCF    0A.4
003D:  GOTO   07F
003E:  BSF    0A.3
003F:  BCF    0A.4
0040:  GOTO   000
.................... #include <16f887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0041:  MOVLW  10
0042:  BSF    03.5
0043:  MOVWF  3B
0044:  CLRF   77
0045:  CLRF   7A
0046:  RRF    38,F
0047:  RRF    37,F
0048:  BTFSS  03.0
0049:  GOTO   050
004A:  MOVF   39,W
004B:  ADDWF  77,F
004C:  BTFSC  03.0
004D:  INCF   7A,F
004E:  MOVF   3A,W
004F:  ADDWF  7A,F
0050:  RRF    7A,F
0051:  RRF    77,F
0052:  RRF    79,F
0053:  RRF    78,F
0054:  DECFSZ 3B,F
0055:  GOTO   046
0056:  BCF    03.5
0057:  RETURN
0058:  CLRF   78
0059:  CLRF   79
005A:  CLRF   77
005B:  CLRF   7A
005C:  BSF    03.5
005D:  MOVF   3C,W
005E:  BTFSS  03.2
005F:  GOTO   063
0060:  MOVF   3B,W
0061:  BTFSC  03.2
0062:  GOTO   07D
0063:  MOVLW  10
0064:  MOVWF  3D
0065:  BCF    03.0
0066:  RLF    39,F
0067:  RLF    3A,F
0068:  RLF    77,F
0069:  RLF    7A,F
006A:  MOVF   3C,W
006B:  SUBWF  7A,W
006C:  BTFSS  03.2
006D:  GOTO   070
006E:  MOVF   3B,W
006F:  SUBWF  77,W
0070:  BTFSS  03.0
0071:  GOTO   079
0072:  MOVF   3B,W
0073:  SUBWF  77,F
0074:  BTFSS  03.0
0075:  DECF   7A,F
0076:  MOVF   3C,W
0077:  SUBWF  7A,F
0078:  BSF    03.0
0079:  RLF    78,F
007A:  RLF    79,F
007B:  DECFSZ 3D,F
007C:  GOTO   065
007D:  BCF    03.5
007E:  RETURN
*
0103:  CLRF   77
0104:  CLRF   78
0105:  MOVF   3E,W
0106:  BCF    03.0
0107:  BTFSC  3F.0
0108:  ADDWF  77,F
0109:  RRF    77,F
010A:  RRF    78,F
010B:  BTFSC  3F.1
010C:  ADDWF  77,F
010D:  RRF    77,F
010E:  RRF    78,F
010F:  BTFSC  3F.2
0110:  ADDWF  77,F
0111:  RRF    77,F
0112:  RRF    78,F
0113:  BTFSC  3F.3
0114:  ADDWF  77,F
0115:  RRF    77,F
0116:  RRF    78,F
0117:  BTFSC  3F.4
0118:  ADDWF  77,F
0119:  RRF    77,F
011A:  RRF    78,F
011B:  BTFSC  3F.5
011C:  ADDWF  77,F
011D:  RRF    77,F
011E:  RRF    78,F
011F:  BTFSC  3F.6
0120:  ADDWF  77,F
0121:  RRF    77,F
0122:  RRF    78,F
0123:  BTFSC  3F.7
0124:  ADDWF  77,F
0125:  RRF    77,F
0126:  RRF    78,F
*
01DB:  BTFSC  03.1
01DC:  GOTO   1E0
01DD:  MOVLW  D5
01DE:  MOVWF  04
01DF:  BCF    03.7
01E0:  BSF    03.5
01E1:  MOVF   50,W
01E2:  XORWF  54,W
01E3:  ANDLW  80
01E4:  MOVWF  5A
01E5:  BTFSS  50.7
01E6:  GOTO   1F2
01E7:  COMF   4D,F
01E8:  COMF   4E,F
01E9:  COMF   4F,F
01EA:  COMF   50,F
01EB:  INCF   4D,F
01EC:  BTFSC  03.2
01ED:  INCF   4E,F
01EE:  BTFSC  03.2
01EF:  INCF   4F,F
01F0:  BTFSC  03.2
01F1:  INCF   50,F
01F2:  BTFSS  54.7
01F3:  GOTO   1FF
01F4:  COMF   51,F
01F5:  COMF   52,F
01F6:  COMF   53,F
01F7:  COMF   54,F
01F8:  INCF   51,F
01F9:  BTFSC  03.2
01FA:  INCF   52,F
01FB:  BTFSC  03.2
01FC:  INCF   53,F
01FD:  BTFSC  03.2
01FE:  INCF   54,F
01FF:  CLRF   77
0200:  CLRF   78
0201:  CLRF   79
0202:  CLRF   7A
0203:  CLRF   55
0204:  CLRF   56
0205:  CLRF   57
0206:  CLRF   58
0207:  MOVF   54,W
0208:  IORWF  53,W
0209:  IORWF  52,W
020A:  IORWF  51,W
020B:  BTFSC  03.2
020C:  GOTO   23D
020D:  MOVLW  20
020E:  MOVWF  59
020F:  BCF    03.0
0210:  RLF    4D,F
0211:  RLF    4E,F
0212:  RLF    4F,F
0213:  RLF    50,F
0214:  RLF    55,F
0215:  RLF    56,F
0216:  RLF    57,F
0217:  RLF    58,F
0218:  MOVF   54,W
0219:  SUBWF  58,W
021A:  BTFSS  03.2
021B:  GOTO   226
021C:  MOVF   53,W
021D:  SUBWF  57,W
021E:  BTFSS  03.2
021F:  GOTO   226
0220:  MOVF   52,W
0221:  SUBWF  56,W
0222:  BTFSS  03.2
0223:  GOTO   226
0224:  MOVF   51,W
0225:  SUBWF  55,W
0226:  BTFSS  03.0
0227:  GOTO   237
0228:  MOVF   51,W
0229:  SUBWF  55,F
022A:  MOVF   52,W
022B:  BTFSS  03.0
022C:  INCFSZ 52,W
022D:  SUBWF  56,F
022E:  MOVF   53,W
022F:  BTFSS  03.0
0230:  INCFSZ 53,W
0231:  SUBWF  57,F
0232:  MOVF   54,W
0233:  BTFSS  03.0
0234:  INCFSZ 54,W
0235:  SUBWF  58,F
0236:  BSF    03.0
0237:  RLF    77,F
0238:  RLF    78,F
0239:  RLF    79,F
023A:  RLF    7A,F
023B:  DECFSZ 59,F
023C:  GOTO   20F
023D:  BTFSS  5A.7
023E:  GOTO   24A
023F:  COMF   77,F
0240:  COMF   78,F
0241:  COMF   79,F
0242:  COMF   7A,F
0243:  INCF   77,F
0244:  BTFSC  03.2
0245:  INCF   78,F
0246:  BTFSC  03.2
0247:  INCF   79,F
0248:  BTFSC  03.2
0249:  INCF   7A,F
024A:  MOVF   55,W
024B:  MOVWF  00
024C:  INCF   04,F
024D:  MOVF   56,W
024E:  MOVWF  00
024F:  INCF   04,F
0250:  MOVF   57,W
0251:  MOVWF  00
0252:  INCF   04,F
0253:  MOVF   58,W
0254:  MOVWF  00
0255:  BCF    03.5
0256:  RETURN
*
02BF:  BSF    03.5
02C0:  MOVF   3A,W
02C1:  BTFSC  03.2
02C2:  GOTO   330
02C3:  MOVWF  42
02C4:  MOVF   3E,W
02C5:  BTFSC  03.2
02C6:  GOTO   330
02C7:  ADDWF  42,F
02C8:  BTFSC  03.0
02C9:  GOTO   2D1
02CA:  MOVLW  7F
02CB:  SUBWF  42,F
02CC:  BTFSS  03.0
02CD:  GOTO   330
02CE:  BTFSC  03.2
02CF:  GOTO   330
02D0:  GOTO   2D5
02D1:  MOVLW  81
02D2:  ADDWF  42,F
02D3:  BTFSC  03.0
02D4:  GOTO   330
02D5:  MOVF   42,W
02D6:  MOVWF  77
02D7:  CLRF   78
02D8:  CLRF   79
02D9:  CLRF   7A
02DA:  MOVF   3B,W
02DB:  MOVWF  46
02DC:  BSF    46.7
02DD:  MOVF   3C,W
02DE:  MOVWF  45
02DF:  MOVF   3D,W
02E0:  MOVWF  44
02E1:  MOVLW  18
02E2:  MOVWF  42
02E3:  CLRF   43
02E4:  BTFSS  44.0
02E5:  GOTO   2FE
02E6:  MOVF   41,W
02E7:  ADDWF  7A,F
02E8:  BTFSS  03.0
02E9:  GOTO   2F0
02EA:  INCF   79,F
02EB:  BTFSS  03.2
02EC:  GOTO   2F0
02ED:  INCF   78,F
02EE:  BTFSC  03.2
02EF:  BSF    43.7
02F0:  MOVF   40,W
02F1:  ADDWF  79,F
02F2:  BTFSS  03.0
02F3:  GOTO   2F7
02F4:  INCF   78,F
02F5:  BTFSC  03.2
02F6:  BSF    43.7
02F7:  MOVF   3F,W
02F8:  MOVWF  3C
02F9:  BSF    3C.7
02FA:  MOVF   3C,W
02FB:  ADDWF  78,F
02FC:  BTFSC  03.0
02FD:  BSF    43.7
02FE:  RLF    43,F
02FF:  RRF    78,F
0300:  RRF    79,F
0301:  RRF    7A,F
0302:  RRF    46,F
0303:  RRF    45,F
0304:  RRF    44,F
0305:  BCF    03.0
0306:  DECFSZ 42,F
0307:  GOTO   2E3
0308:  MOVLW  01
0309:  ADDWF  77,F
030A:  BTFSC  03.0
030B:  GOTO   330
030C:  BTFSC  78.7
030D:  GOTO   315
030E:  RLF    46,F
030F:  RLF    7A,F
0310:  RLF    79,F
0311:  RLF    78,F
0312:  DECF   77,F
0313:  BTFSC  03.2
0314:  GOTO   330
0315:  BTFSS  46.7
0316:  GOTO   326
0317:  INCF   7A,F
0318:  BTFSS  03.2
0319:  GOTO   326
031A:  INCF   79,F
031B:  BTFSS  03.2
031C:  GOTO   326
031D:  INCF   78,F
031E:  BTFSS  03.2
031F:  GOTO   326
0320:  RRF    78,F
0321:  RRF    79,F
0322:  RRF    7A,F
0323:  INCF   77,F
0324:  BTFSC  03.2
0325:  GOTO   330
0326:  MOVF   3B,W
0327:  MOVWF  43
0328:  MOVF   3F,W
0329:  XORWF  43,F
032A:  BTFSS  43.7
032B:  GOTO   32E
032C:  BSF    78.7
032D:  GOTO   334
032E:  BCF    78.7
032F:  GOTO   334
0330:  CLRF   77
0331:  CLRF   78
0332:  CLRF   79
0333:  CLRF   7A
0334:  BCF    03.5
0335:  RETURN
0336:  MOVLW  80
0337:  BTFSS  03.1
0338:  GOTO   33C
0339:  BSF    03.5
033A:  XORWF  3F,F
033B:  BCF    03.5
033C:  BSF    03.5
033D:  CLRF   44
033E:  CLRF   45
033F:  MOVF   3B,W
0340:  MOVWF  43
0341:  MOVF   3F,W
0342:  XORWF  43,F
0343:  MOVF   3A,W
0344:  BTFSC  03.2
0345:  GOTO   42A
0346:  MOVWF  42
0347:  MOVWF  77
0348:  MOVF   3E,W
0349:  BTFSC  03.2
034A:  GOTO   433
034B:  SUBWF  42,F
034C:  BTFSC  03.2
034D:  GOTO   3CF
034E:  BTFSS  03.0
034F:  GOTO   38D
0350:  MOVF   3F,W
0351:  MOVWF  48
0352:  BSF    48.7
0353:  MOVF   40,W
0354:  MOVWF  47
0355:  MOVF   41,W
0356:  MOVWF  46
0357:  CLRF   45
0358:  BCF    03.0
0359:  RRF    48,F
035A:  RRF    47,F
035B:  RRF    46,F
035C:  RRF    45,F
035D:  DECFSZ 42,F
035E:  GOTO   357
035F:  BTFSS  43.7
0360:  GOTO   364
0361:  BSF    44.0
0362:  GOTO   447
0363:  BCF    44.0
0364:  BCF    42.0
0365:  BSF    44.4
0366:  MOVLW  BD
0367:  MOVWF  04
0368:  BCF    03.7
0369:  GOTO   45C
036A:  BCF    44.4
036B:  BTFSC  43.7
036C:  GOTO   377
036D:  BTFSS  42.0
036E:  GOTO   382
036F:  RRF    48,F
0370:  RRF    47,F
0371:  RRF    46,F
0372:  RRF    45,F
0373:  INCF   77,F
0374:  BTFSC  03.2
0375:  GOTO   442
0376:  GOTO   382
0377:  BTFSC  48.7
0378:  GOTO   385
0379:  BCF    03.0
037A:  RLF    45,F
037B:  RLF    46,F
037C:  RLF    47,F
037D:  RLF    48,F
037E:  DECF   77,F
037F:  BTFSC  03.2
0380:  GOTO   442
0381:  GOTO   377
0382:  BSF    44.6
0383:  GOTO   3EF
0384:  BCF    44.6
0385:  MOVF   3B,W
0386:  MOVWF  43
0387:  BTFSS  43.7
0388:  GOTO   38B
0389:  BSF    48.7
038A:  GOTO   43B
038B:  BCF    48.7
038C:  GOTO   43B
038D:  MOVF   3E,W
038E:  MOVWF  42
038F:  MOVWF  77
0390:  MOVF   3A,W
0391:  SUBWF  42,F
0392:  MOVF   3B,W
0393:  MOVWF  48
0394:  BSF    48.7
0395:  MOVF   3C,W
0396:  MOVWF  47
0397:  MOVF   3D,W
0398:  MOVWF  46
0399:  CLRF   45
039A:  BCF    03.0
039B:  RRF    48,F
039C:  RRF    47,F
039D:  RRF    46,F
039E:  RRF    45,F
039F:  DECFSZ 42,F
03A0:  GOTO   399
03A1:  BTFSS  43.7
03A2:  GOTO   3A6
03A3:  BSF    44.1
03A4:  GOTO   447
03A5:  BCF    44.1
03A6:  BCF    42.0
03A7:  BSF    44.5
03A8:  MOVLW  C1
03A9:  MOVWF  04
03AA:  BCF    03.7
03AB:  GOTO   45C
03AC:  BCF    44.5
03AD:  BTFSC  43.7
03AE:  GOTO   3B9
03AF:  BTFSS  42.0
03B0:  GOTO   3C4
03B1:  RRF    48,F
03B2:  RRF    47,F
03B3:  RRF    46,F
03B4:  RRF    45,F
03B5:  INCF   77,F
03B6:  BTFSC  03.2
03B7:  GOTO   442
03B8:  GOTO   3C4
03B9:  BTFSC  48.7
03BA:  GOTO   3C7
03BB:  BCF    03.0
03BC:  RLF    45,F
03BD:  RLF    46,F
03BE:  RLF    47,F
03BF:  RLF    48,F
03C0:  DECF   77,F
03C1:  BTFSC  03.2
03C2:  GOTO   442
03C3:  GOTO   3B9
03C4:  BSF    44.7
03C5:  GOTO   3EF
03C6:  BCF    44.7
03C7:  MOVF   3F,W
03C8:  MOVWF  43
03C9:  BTFSS  43.7
03CA:  GOTO   3CD
03CB:  BSF    48.7
03CC:  GOTO   43B
03CD:  BCF    48.7
03CE:  GOTO   43B
03CF:  MOVF   3F,W
03D0:  MOVWF  48
03D1:  BSF    48.7
03D2:  MOVF   40,W
03D3:  MOVWF  47
03D4:  MOVF   41,W
03D5:  MOVWF  46
03D6:  BTFSS  43.7
03D7:  GOTO   3DC
03D8:  BCF    48.7
03D9:  BSF    44.2
03DA:  GOTO   447
03DB:  BCF    44.2
03DC:  CLRF   45
03DD:  BCF    42.0
03DE:  MOVLW  BD
03DF:  MOVWF  04
03E0:  BCF    03.7
03E1:  GOTO   45C
03E2:  BTFSC  43.7
03E3:  GOTO   405
03E4:  MOVF   3B,W
03E5:  MOVWF  43
03E6:  BTFSS  42.0
03E7:  GOTO   3EF
03E8:  RRF    48,F
03E9:  RRF    47,F
03EA:  RRF    46,F
03EB:  RRF    45,F
03EC:  INCF   77,F
03ED:  BTFSC  03.2
03EE:  GOTO   442
03EF:  BTFSS  45.7
03F0:  GOTO   400
03F1:  INCF   46,F
03F2:  BTFSS  03.2
03F3:  GOTO   400
03F4:  INCF   47,F
03F5:  BTFSS  03.2
03F6:  GOTO   400
03F7:  INCF   48,F
03F8:  BTFSS  03.2
03F9:  GOTO   400
03FA:  RRF    48,F
03FB:  RRF    47,F
03FC:  RRF    46,F
03FD:  INCF   77,F
03FE:  BTFSC  03.2
03FF:  GOTO   442
0400:  BTFSC  44.6
0401:  GOTO   384
0402:  BTFSC  44.7
0403:  GOTO   3C6
0404:  GOTO   424
0405:  MOVLW  80
0406:  XORWF  48,F
0407:  BTFSS  48.7
0408:  GOTO   40D
0409:  GOTO   447
040A:  MOVF   3F,W
040B:  MOVWF  43
040C:  GOTO   41A
040D:  MOVF   3B,W
040E:  MOVWF  43
040F:  MOVF   48,F
0410:  BTFSS  03.2
0411:  GOTO   41A
0412:  MOVF   47,F
0413:  BTFSS  03.2
0414:  GOTO   41A
0415:  MOVF   46,F
0416:  BTFSS  03.2
0417:  GOTO   41A
0418:  CLRF   77
0419:  GOTO   43B
041A:  BTFSC  48.7
041B:  GOTO   424
041C:  BCF    03.0
041D:  RLF    45,F
041E:  RLF    46,F
041F:  RLF    47,F
0420:  RLF    48,F
0421:  DECFSZ 77,F
0422:  GOTO   41A
0423:  GOTO   442
0424:  BTFSS  43.7
0425:  GOTO   428
0426:  BSF    48.7
0427:  GOTO   43B
0428:  BCF    48.7
0429:  GOTO   43B
042A:  MOVF   3E,W
042B:  MOVWF  77
042C:  MOVF   3F,W
042D:  MOVWF  48
042E:  MOVF   40,W
042F:  MOVWF  47
0430:  MOVF   41,W
0431:  MOVWF  46
0432:  GOTO   43B
0433:  MOVF   3A,W
0434:  MOVWF  77
0435:  MOVF   3B,W
0436:  MOVWF  48
0437:  MOVF   3C,W
0438:  MOVWF  47
0439:  MOVF   3D,W
043A:  MOVWF  46
043B:  MOVF   48,W
043C:  MOVWF  78
043D:  MOVF   47,W
043E:  MOVWF  79
043F:  MOVF   46,W
0440:  MOVWF  7A
0441:  GOTO   47A
0442:  CLRF   77
0443:  CLRF   78
0444:  CLRF   79
0445:  CLRF   7A
0446:  GOTO   47A
0447:  CLRF   45
0448:  COMF   46,F
0449:  COMF   47,F
044A:  COMF   48,F
044B:  COMF   45,F
044C:  INCF   45,F
044D:  BTFSS  03.2
044E:  GOTO   455
044F:  INCF   46,F
0450:  BTFSS  03.2
0451:  GOTO   455
0452:  INCF   47,F
0453:  BTFSC  03.2
0454:  INCF   48,F
0455:  BTFSC  44.0
0456:  GOTO   363
0457:  BTFSC  44.1
0458:  GOTO   3A5
0459:  BTFSC  44.2
045A:  GOTO   3DB
045B:  GOTO   40A
045C:  MOVF   00,W
045D:  ADDWF  46,F
045E:  BTFSS  03.0
045F:  GOTO   466
0460:  INCF   47,F
0461:  BTFSS  03.2
0462:  GOTO   466
0463:  INCF   48,F
0464:  BTFSC  03.2
0465:  BSF    42.0
0466:  DECF   04,F
0467:  MOVF   00,W
0468:  ADDWF  47,F
0469:  BTFSS  03.0
046A:  GOTO   46E
046B:  INCF   48,F
046C:  BTFSC  03.2
046D:  BSF    42.0
046E:  DECF   04,F
046F:  MOVF   00,W
0470:  BTFSS  00.7
0471:  XORLW  80
0472:  ADDWF  48,F
0473:  BTFSC  03.0
0474:  BSF    42.0
0475:  BTFSC  44.4
0476:  GOTO   36A
0477:  BTFSC  44.5
0478:  GOTO   3AC
0479:  GOTO   3E2
047A:  BCF    03.5
047B:  RETURN
047C:  BSF    03.5
047D:  MOVF   37,W
047E:  MOVWF  3E
047F:  MOVF   3B,W
0480:  XORWF  3E,F
0481:  BTFSS  3E.7
0482:  GOTO   488
0483:  BCF    03.2
0484:  BCF    03.0
0485:  BTFSC  37.7
0486:  BSF    03.0
0487:  GOTO   4BB
0488:  MOVF   37,W
0489:  MOVWF  3E
048A:  MOVF   3A,W
048B:  MOVWF  3F
048C:  MOVF   36,W
048D:  SUBWF  3F,F
048E:  BTFSC  03.2
048F:  GOTO   496
0490:  BTFSS  3E.7
0491:  GOTO   4BB
0492:  MOVF   03,W
0493:  XORLW  01
0494:  MOVWF  03
0495:  GOTO   4BB
0496:  MOVF   3B,W
0497:  MOVWF  3F
0498:  MOVF   37,W
0499:  SUBWF  3F,F
049A:  BTFSC  03.2
049B:  GOTO   4A2
049C:  BTFSS  3E.7
049D:  GOTO   4BB
049E:  MOVF   03,W
049F:  XORLW  01
04A0:  MOVWF  03
04A1:  GOTO   4BB
04A2:  MOVF   3C,W
04A3:  MOVWF  3F
04A4:  MOVF   38,W
04A5:  SUBWF  3F,F
04A6:  BTFSC  03.2
04A7:  GOTO   4AE
04A8:  BTFSS  3E.7
04A9:  GOTO   4BB
04AA:  MOVF   03,W
04AB:  XORLW  01
04AC:  MOVWF  03
04AD:  GOTO   4BB
04AE:  MOVF   3D,W
04AF:  MOVWF  3F
04B0:  MOVF   39,W
04B1:  SUBWF  3F,F
04B2:  BTFSC  03.2
04B3:  GOTO   4BA
04B4:  BTFSS  3E.7
04B5:  GOTO   4BB
04B6:  MOVF   03,W
04B7:  XORLW  01
04B8:  MOVWF  03
04B9:  GOTO   4BB
04BA:  BCF    03.0
04BB:  BCF    03.5
04BC:  RETURN
*
04F8:  MOVLW  20
04F9:  MOVWF  51
04FA:  CLRF   4D
04FB:  CLRF   4E
04FC:  CLRF   4F
04FD:  CLRF   50
04FE:  MOVF   48,W
04FF:  MOVWF  7A
0500:  MOVF   47,W
0501:  MOVWF  79
0502:  MOVF   46,W
0503:  MOVWF  78
0504:  MOVF   45,W
0505:  MOVWF  77
0506:  BCF    03.0
0507:  BTFSS  77.0
0508:  GOTO   517
0509:  MOVF   49,W
050A:  ADDWF  4D,F
050B:  MOVF   4A,W
050C:  BTFSC  03.0
050D:  INCFSZ 4A,W
050E:  ADDWF  4E,F
050F:  MOVF   4B,W
0510:  BTFSC  03.0
0511:  INCFSZ 4B,W
0512:  ADDWF  4F,F
0513:  MOVF   4C,W
0514:  BTFSC  03.0
0515:  INCFSZ 4C,W
0516:  ADDWF  50,F
0517:  RRF    50,F
0518:  RRF    4F,F
0519:  RRF    4E,F
051A:  RRF    4D,F
051B:  RRF    7A,F
051C:  RRF    79,F
051D:  RRF    78,F
051E:  RRF    77,F
051F:  DECFSZ 51,F
0520:  GOTO   506
*
0603:  MOVF   00,F
0604:  BTFSC  03.2
0605:  GOTO   626
0606:  CLRF   37
0607:  MOVF   04,W
0608:  MOVWF  36
0609:  BCF    37.0
060A:  BTFSC  03.7
060B:  BSF    37.0
060C:  MOVF   00,W
060D:  MOVWF  38
060E:  MOVF   73,W
060F:  MOVWF  04
0610:  BCF    03.7
0611:  BTFSC  74.0
0612:  BSF    03.7
0613:  MOVF   38,W
0614:  MOVWF  00
0615:  INCF   04,F
0616:  CLRF   00
0617:  INCF   73,F
0618:  BTFSC  03.2
0619:  INCF   74,F
061A:  MOVF   36,W
061B:  MOVWF  04
061C:  BCF    03.7
061D:  BTFSC  37.0
061E:  BSF    03.7
061F:  INCF   04,F
0620:  BTFSS  03.2
0621:  GOTO   625
0622:  BCF    03.5
0623:  INCF   05,F
0624:  BSF    03.5
0625:  GOTO   603
*
0676:  MOVLW  8E
0677:  MOVWF  77
0678:  MOVF   37,W
0679:  MOVWF  78
067A:  MOVF   36,W
067B:  MOVWF  79
067C:  CLRF   7A
067D:  MOVF   78,F
067E:  BTFSS  03.2
067F:  GOTO   68A
0680:  MOVF   79,W
0681:  MOVWF  78
0682:  CLRF   79
0683:  MOVLW  08
0684:  SUBWF  77,F
0685:  MOVF   78,F
0686:  BTFSS  03.2
0687:  GOTO   68A
0688:  CLRF   77
0689:  GOTO   692
068A:  BCF    03.0
068B:  BTFSC  78.7
068C:  GOTO   691
068D:  RLF    79,F
068E:  RLF    78,F
068F:  DECF   77,F
0690:  GOTO   68A
0691:  BCF    78.7
*
07CF:  MOVLW  8E
07D0:  MOVWF  77
07D1:  MOVF   36,W
07D2:  SUBWF  77,F
07D3:  MOVF   37,W
07D4:  MOVWF  79
07D5:  MOVF   38,W
07D6:  MOVWF  78
07D7:  BSF    79.7
07D8:  MOVF   77,F
07D9:  BTFSC  03.2
07DA:  GOTO   7E6
07DB:  BCF    03.0
07DC:  MOVF   79,F
07DD:  BTFSS  03.2
07DE:  GOTO   7E2
07DF:  MOVF   78,F
07E0:  BTFSC  03.2
07E1:  GOTO   7E6
07E2:  RRF    79,F
07E3:  RRF    78,F
07E4:  DECFSZ 77,F
07E5:  GOTO   7DB
07E6:  BTFSS  37.7
07E7:  GOTO   7ED
07E8:  COMF   78,F
07E9:  COMF   79,F
07EA:  INCF   78,F
07EB:  BTFSC  03.2
07EC:  INCF   79,F
*
08BB:  BSF    03.5
08BC:  MOVF   28,W
08BD:  BTFSC  03.2
08BE:  GOTO   181
08BF:  MOVWF  34
08C0:  MOVF   2C,W
08C1:  BTFSC  03.2
08C2:  GOTO   181
08C3:  SUBWF  34,F
08C4:  BTFSS  03.0
08C5:  GOTO   0CB
08C6:  MOVLW  7F
08C7:  ADDWF  34,F
08C8:  BTFSC  03.0
08C9:  GOTO   181
08CA:  GOTO   0D1
08CB:  MOVLW  81
08CC:  SUBWF  34,F
08CD:  BTFSS  03.0
08CE:  GOTO   181
08CF:  BTFSC  03.2
08D0:  GOTO   181
08D1:  MOVF   34,W
08D2:  MOVWF  77
08D3:  CLRF   78
08D4:  CLRF   79
08D5:  CLRF   7A
08D6:  CLRF   33
08D7:  MOVF   29,W
08D8:  MOVWF  32
08D9:  BSF    32.7
08DA:  MOVF   2A,W
08DB:  MOVWF  31
08DC:  MOVF   2B,W
08DD:  MOVWF  30
08DE:  MOVLW  19
08DF:  MOVWF  34
08E0:  MOVF   2F,W
08E1:  SUBWF  30,F
08E2:  BTFSC  03.0
08E3:  GOTO   0F4
08E4:  MOVLW  01
08E5:  SUBWF  31,F
08E6:  BTFSC  03.0
08E7:  GOTO   0F4
08E8:  SUBWF  32,F
08E9:  BTFSC  03.0
08EA:  GOTO   0F4
08EB:  SUBWF  33,F
08EC:  BTFSC  03.0
08ED:  GOTO   0F4
08EE:  INCF   33,F
08EF:  INCF   32,F
08F0:  INCF   31,F
08F1:  MOVF   2F,W
08F2:  ADDWF  30,F
08F3:  GOTO   126
08F4:  MOVF   2E,W
08F5:  SUBWF  31,F
08F6:  BTFSC  03.0
08F7:  GOTO   10F
08F8:  MOVLW  01
08F9:  SUBWF  32,F
08FA:  BTFSC  03.0
08FB:  GOTO   10F
08FC:  SUBWF  33,F
08FD:  BTFSC  03.0
08FE:  GOTO   10F
08FF:  INCF   33,F
0900:  INCF   32,F
0901:  MOVF   2E,W
0902:  ADDWF  31,F
0903:  MOVF   2F,W
0904:  ADDWF  30,F
0905:  BTFSS  03.0
0906:  GOTO   126
0907:  INCF   31,F
0908:  BTFSS  03.2
0909:  GOTO   126
090A:  INCF   32,F
090B:  BTFSS  03.2
090C:  GOTO   126
090D:  INCF   33,F
090E:  GOTO   126
090F:  MOVF   2D,W
0910:  IORLW  80
0911:  SUBWF  32,F
0912:  BTFSC  03.0
0913:  GOTO   125
0914:  MOVLW  01
0915:  SUBWF  33,F
0916:  BTFSC  03.0
0917:  GOTO   125
0918:  INCF   33,F
0919:  MOVF   2D,W
091A:  IORLW  80
091B:  ADDWF  32,F
091C:  MOVF   2E,W
091D:  ADDWF  31,F
091E:  BTFSS  03.0
091F:  GOTO   103
0920:  INCF   32,F
0921:  BTFSS  03.2
0922:  GOTO   103
0923:  INCF   33,F
0924:  GOTO   103
0925:  BSF    7A.0
0926:  DECFSZ 34,F
0927:  GOTO   129
0928:  GOTO   134
0929:  BCF    03.0
092A:  RLF    30,F
092B:  RLF    31,F
092C:  RLF    32,F
092D:  RLF    33,F
092E:  BCF    03.0
092F:  RLF    7A,F
0930:  RLF    79,F
0931:  RLF    78,F
0932:  RLF    35,F
0933:  GOTO   0E0
0934:  BTFSS  35.0
0935:  GOTO   13C
0936:  BCF    03.0
0937:  RRF    78,F
0938:  RRF    79,F
0939:  RRF    7A,F
093A:  RRF    35,F
093B:  GOTO   13F
093C:  DECF   77,F
093D:  BTFSC  03.2
093E:  GOTO   181
093F:  BTFSC  35.7
0940:  GOTO   168
0941:  BCF    03.0
0942:  RLF    30,F
0943:  RLF    31,F
0944:  RLF    32,F
0945:  RLF    33,F
0946:  MOVF   2F,W
0947:  SUBWF  30,F
0948:  BTFSC  03.0
0949:  GOTO   154
094A:  MOVLW  01
094B:  SUBWF  31,F
094C:  BTFSC  03.0
094D:  GOTO   154
094E:  SUBWF  32,F
094F:  BTFSC  03.0
0950:  GOTO   154
0951:  SUBWF  33,F
0952:  BTFSS  03.0
0953:  GOTO   177
0954:  MOVF   2E,W
0955:  SUBWF  31,F
0956:  BTFSC  03.0
0957:  GOTO   15F
0958:  MOVLW  01
0959:  SUBWF  32,F
095A:  BTFSC  03.0
095B:  GOTO   15F
095C:  SUBWF  33,F
095D:  BTFSS  03.0
095E:  GOTO   177
095F:  MOVF   2D,W
0960:  IORLW  80
0961:  SUBWF  32,F
0962:  BTFSC  03.0
0963:  GOTO   168
0964:  MOVLW  01
0965:  SUBWF  33,F
0966:  BTFSS  03.0
0967:  GOTO   177
0968:  INCF   7A,F
0969:  BTFSS  03.2
096A:  GOTO   177
096B:  INCF   79,F
096C:  BTFSS  03.2
096D:  GOTO   177
096E:  INCF   78,F
096F:  BTFSS  03.2
0970:  GOTO   177
0971:  INCF   77,F
0972:  BTFSC  03.2
0973:  GOTO   181
0974:  RRF    78,F
0975:  RRF    79,F
0976:  RRF    7A,F
0977:  MOVF   29,W
0978:  MOVWF  34
0979:  MOVF   2D,W
097A:  XORWF  34,F
097B:  BTFSS  34.7
097C:  GOTO   17F
097D:  BSF    78.7
097E:  GOTO   185
097F:  BCF    78.7
0980:  GOTO   185
0981:  CLRF   77
0982:  CLRF   78
0983:  CLRF   79
0984:  CLRF   7A
0985:  BCF    03.5
0986:  RETURN
....................  
.................... #list 
....................  
.................... #FUSES NOWDT, HS, NOPUT,NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT 
.................... #use delay(clock=8000000) 
*
0257:  MOVLW  B9
0258:  MOVWF  04
0259:  BCF    03.7
025A:  MOVF   00,W
025B:  BTFSC  03.2
025C:  GOTO   26A
025D:  MOVLW  02
025E:  MOVWF  78
025F:  CLRF   77
0260:  DECFSZ 77,F
0261:  GOTO   260
0262:  DECFSZ 78,F
0263:  GOTO   25F
0264:  MOVLW  97
0265:  MOVWF  77
0266:  DECFSZ 77,F
0267:  GOTO   266
0268:  DECFSZ 00,F
0269:  GOTO   25D
026A:  RETURN
.................... #use rs232 (baud=9600 , parity=n , xmit=pin_C6 , rcv=pin_C7 )  
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
09BA:  BCF    03.6
09BB:  CLRF   28
09BC:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0095:  CLRF   3C
....................    sign = 0; 
0096:  CLRF   3A
....................    base = 10; 
0097:  MOVLW  0A
0098:  MOVWF  3B
....................    result = 0; 
0099:  CLRF   39
....................  
....................    if (!s) 
009A:  MOVF   37,W
009B:  IORWF  38,W
009C:  BTFSS  03.2
009D:  GOTO   0A1
....................       return 0; 
009E:  MOVLW  00
009F:  MOVWF  78
00A0:  GOTO   194
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
00A1:  MOVF   3C,W
00A2:  INCF   3C,F
00A3:  ADDWF  37,W
00A4:  MOVWF  04
00A5:  BCF    03.7
00A6:  BTFSC  38.0
00A7:  BSF    03.7
00A8:  MOVF   00,W
00A9:  MOVWF  3D
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
00AA:  MOVF   3D,W
00AB:  SUBLW  2D
00AC:  BTFSS  03.2
00AD:  GOTO   0BA
....................    { 
....................       sign = 1;         // Set the sign to negative 
00AE:  MOVLW  01
00AF:  MOVWF  3A
....................       c = s[index++]; 
00B0:  MOVF   3C,W
00B1:  INCF   3C,F
00B2:  ADDWF  37,W
00B3:  MOVWF  04
00B4:  BCF    03.7
00B5:  BTFSC  38.0
00B6:  BSF    03.7
00B7:  MOVF   00,W
00B8:  MOVWF  3D
....................    } 
00B9:  GOTO   0C7
....................    else if (c == '+') 
00BA:  MOVF   3D,W
00BB:  SUBLW  2B
00BC:  BTFSS  03.2
00BD:  GOTO   0C7
....................    { 
....................       c = s[index++]; 
00BE:  MOVF   3C,W
00BF:  INCF   3C,F
00C0:  ADDWF  37,W
00C1:  MOVWF  04
00C2:  BCF    03.7
00C3:  BTFSC  38.0
00C4:  BSF    03.7
00C5:  MOVF   00,W
00C6:  MOVWF  3D
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
00C7:  MOVF   3D,W
00C8:  SUBLW  2F
00C9:  BTFSC  03.0
00CA:  GOTO   18A
00CB:  MOVF   3D,W
00CC:  SUBLW  39
00CD:  BTFSS  03.0
00CE:  GOTO   18A
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
00CF:  MOVF   3D,W
00D0:  SUBLW  30
00D1:  BTFSS  03.2
00D2:  GOTO   0F3
00D3:  MOVF   3C,W
00D4:  ADDWF  37,W
00D5:  MOVWF  04
00D6:  BCF    03.7
00D7:  BTFSC  38.0
00D8:  BSF    03.7
00D9:  MOVF   00,W
00DA:  SUBLW  78
00DB:  BTFSC  03.2
00DC:  GOTO   0E7
00DD:  MOVF   3C,W
00DE:  ADDWF  37,W
00DF:  MOVWF  04
00E0:  BCF    03.7
00E1:  BTFSC  38.0
00E2:  BSF    03.7
00E3:  MOVF   00,W
00E4:  SUBLW  58
00E5:  BTFSS  03.2
00E6:  GOTO   0F3
....................       { 
....................          base = 16; 
00E7:  MOVLW  10
00E8:  MOVWF  3B
....................          index++; 
00E9:  INCF   3C,F
....................          c = s[index++]; 
00EA:  MOVF   3C,W
00EB:  INCF   3C,F
00EC:  ADDWF  37,W
00ED:  MOVWF  04
00EE:  BCF    03.7
00EF:  BTFSC  38.0
00F0:  BSF    03.7
00F1:  MOVF   00,W
00F2:  MOVWF  3D
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
00F3:  MOVF   3B,W
00F4:  SUBLW  0A
00F5:  BTFSS  03.2
00F6:  GOTO   138
....................       { 
....................          while (c >= '0' && c <= '9') 
00F7:  MOVF   3D,W
00F8:  SUBLW  2F
00F9:  BTFSC  03.0
00FA:  GOTO   137
00FB:  MOVF   3D,W
00FC:  SUBLW  39
00FD:  BTFSS  03.0
00FE:  GOTO   137
....................          { 
....................             result = 10*result + (c - '0'); 
00FF:  MOVLW  0A
0100:  MOVWF  3E
0101:  MOVF   39,W
0102:  MOVWF  3F
*
0127:  MOVF   78,W
0128:  MOVWF  3E
0129:  MOVLW  30
012A:  SUBWF  3D,W
012B:  ADDWF  3E,W
012C:  MOVWF  39
....................             c = s[index++]; 
012D:  MOVF   3C,W
012E:  INCF   3C,F
012F:  ADDWF  37,W
0130:  MOVWF  04
0131:  BCF    03.7
0132:  BTFSC  38.0
0133:  BSF    03.7
0134:  MOVF   00,W
0135:  MOVWF  3D
0136:  GOTO   0F7
....................          } 
....................       } 
0137:  GOTO   18A
....................       else if (base == 16)    // The number is a hexa number 
0138:  MOVF   3B,W
0139:  SUBLW  10
013A:  BTFSS  03.2
013B:  GOTO   18A
....................       { 
....................          c = toupper(c); 
013C:  MOVF   3D,W
013D:  SUBLW  60
013E:  BTFSC  03.0
013F:  GOTO   147
0140:  MOVF   3D,W
0141:  SUBLW  7A
0142:  BTFSS  03.0
0143:  GOTO   147
0144:  MOVF   3D,W
0145:  ANDLW  DF
0146:  GOTO   148
0147:  MOVF   3D,W
0148:  MOVWF  3D
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0149:  MOVF   3D,W
014A:  SUBLW  2F
014B:  BTFSC  03.0
014C:  GOTO   151
014D:  MOVF   3D,W
014E:  SUBLW  39
014F:  BTFSC  03.0
0150:  GOTO   159
0151:  MOVF   3D,W
0152:  SUBLW  40
0153:  BTFSC  03.0
0154:  GOTO   18A
0155:  MOVF   3D,W
0156:  SUBLW  46
0157:  BTFSS  03.0
0158:  GOTO   18A
....................          { 
....................             if (c >= '0' && c <= '9') 
0159:  MOVF   3D,W
015A:  SUBLW  2F
015B:  BTFSC  03.0
015C:  GOTO   16A
015D:  MOVF   3D,W
015E:  SUBLW  39
015F:  BTFSS  03.0
0160:  GOTO   16A
....................                result = (result << 4) + (c - '0'); 
0161:  SWAPF  39,W
0162:  MOVWF  3E
0163:  MOVLW  F0
0164:  ANDWF  3E,F
0165:  MOVLW  30
0166:  SUBWF  3D,W
0167:  ADDWF  3E,W
0168:  MOVWF  39
0169:  GOTO   173
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
016A:  SWAPF  39,W
016B:  MOVWF  3E
016C:  MOVLW  F0
016D:  ANDWF  3E,F
016E:  MOVLW  41
016F:  SUBWF  3D,W
0170:  ADDLW  0A
0171:  ADDWF  3E,W
0172:  MOVWF  39
....................  
....................             c = s[index++]; 
0173:  MOVF   3C,W
0174:  INCF   3C,F
0175:  ADDWF  37,W
0176:  MOVWF  04
0177:  BCF    03.7
0178:  BTFSC  38.0
0179:  BSF    03.7
017A:  MOVF   00,W
017B:  MOVWF  3D
....................             c = toupper(c); 
017C:  MOVF   3D,W
017D:  SUBLW  60
017E:  BTFSC  03.0
017F:  GOTO   187
0180:  MOVF   3D,W
0181:  SUBLW  7A
0182:  BTFSS  03.0
0183:  GOTO   187
0184:  MOVF   3D,W
0185:  ANDLW  DF
0186:  GOTO   188
0187:  MOVF   3D,W
0188:  MOVWF  3D
0189:  GOTO   149
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
018A:  DECFSZ 3A,W
018B:  GOTO   192
018C:  MOVF   3B,W
018D:  SUBLW  0A
018E:  BTFSS  03.2
018F:  GOTO   192
....................        result = -result; 
0190:  COMF   39,F
0191:  INCF   39,F
....................  
....................    return(result); 
0192:  MOVF   39,W
0193:  MOVWF  78
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
04E0:  CLRF   40
04E1:  CLRF   3F
04E2:  CLRF   3E
04E3:  MOVLW  01
04E4:  MOVWF  3D
04E5:  CLRF   42
04E6:  CLRF   43
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
04E7:  BTFSS  39.7
04E8:  GOTO   529
....................          sign=1;        // Check for negative number 
04E9:  MOVLW  01
04EA:  MOVWF  42
....................          num*=-1; 
04EB:  MOVF   39,W
04EC:  MOVWF  48
04ED:  MOVF   38,W
04EE:  MOVWF  47
04EF:  MOVF   37,W
04F0:  MOVWF  46
04F1:  MOVF   36,W
04F2:  MOVWF  45
04F3:  MOVLW  FF
04F4:  MOVWF  4C
04F5:  MOVWF  4B
04F6:  MOVWF  4A
04F7:  MOVWF  49
*
0521:  MOVF   7A,W
0522:  MOVWF  39
0523:  MOVF   79,W
0524:  MOVWF  38
0525:  MOVF   78,W
0526:  MOVWF  37
0527:  MOVF   77,W
0528:  MOVWF  36
....................      } 
....................  
....................      while(temp>0) { 
0529:  MOVF   3D,F
052A:  BTFSS  03.2
052B:  GOTO   535
052C:  MOVF   3E,F
052D:  BTFSS  03.2
052E:  GOTO   535
052F:  MOVF   3F,F
0530:  BTFSS  03.2
0531:  GOTO   535
0532:  MOVF   40,F
0533:  BTFSC  03.2
0534:  GOTO   5B1
....................          temp=(num/base); 
0535:  BCF    03.1
0536:  MOVF   39,W
0537:  MOVWF  50
0538:  MOVF   38,W
0539:  MOVWF  4F
053A:  MOVF   37,W
053B:  MOVWF  4E
053C:  MOVF   36,W
053D:  MOVWF  4D
053E:  CLRF   54
053F:  CLRF   53
0540:  CLRF   52
0541:  MOVF   3A,W
0542:  MOVWF  51
0543:  BCF    03.5
0544:  CALL   1DB
0545:  MOVF   7A,W
0546:  BSF    03.5
0547:  MOVWF  40
0548:  MOVF   79,W
0549:  MOVWF  3F
054A:  MOVF   78,W
054B:  MOVWF  3E
054C:  MOVF   77,W
054D:  MOVWF  3D
....................          s[cnt]=(num%base)+'0';    // Conversion 
054E:  MOVF   43,W
054F:  ADDWF  3B,W
0550:  MOVWF  78
0551:  MOVF   3C,W
0552:  MOVWF  7A
0553:  BTFSC  03.0
0554:  INCF   7A,F
0555:  MOVF   78,W
0556:  MOVWF  45
0557:  MOVF   7A,W
0558:  MOVWF  46
0559:  CLRF   48
055A:  MOVF   04,W
055B:  MOVWF  47
055C:  BCF    48.0
055D:  BTFSC  03.7
055E:  BSF    48.0
055F:  BSF    03.1
0560:  MOVLW  C9
0561:  MOVWF  04
0562:  BCF    03.7
0563:  MOVF   39,W
0564:  MOVWF  50
0565:  MOVF   38,W
0566:  MOVWF  4F
0567:  MOVF   37,W
0568:  MOVWF  4E
0569:  MOVF   36,W
056A:  MOVWF  4D
056B:  CLRF   54
056C:  CLRF   53
056D:  CLRF   52
056E:  MOVF   3A,W
056F:  MOVWF  51
0570:  BCF    03.5
0571:  CALL   1DB
0572:  BSF    03.5
0573:  MOVF   47,W
0574:  MOVWF  04
0575:  BCF    03.7
0576:  BTFSC  48.0
0577:  BSF    03.7
0578:  MOVLW  30
0579:  ADDWF  49,W
057A:  MOVWF  77
057B:  MOVF   4A,W
057C:  MOVWF  78
057D:  MOVLW  00
057E:  BTFSC  03.0
057F:  MOVLW  01
0580:  ADDWF  78,F
0581:  MOVF   4B,W
0582:  MOVWF  79
0583:  MOVLW  00
0584:  BTFSC  03.0
0585:  MOVLW  01
0586:  ADDWF  79,F
0587:  MOVF   4C,W
0588:  MOVWF  7A
0589:  MOVLW  00
058A:  BTFSC  03.0
058B:  MOVLW  01
058C:  ADDWF  7A,F
058D:  MOVF   45,W
058E:  MOVWF  04
058F:  BCF    03.7
0590:  BTFSC  46.0
0591:  BSF    03.7
0592:  MOVF   77,W
0593:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
0594:  MOVF   43,W
0595:  ADDWF  3B,W
0596:  MOVWF  04
0597:  BCF    03.7
0598:  BTFSC  3C.0
0599:  BSF    03.7
059A:  MOVF   00,W
059B:  SUBLW  39
059C:  BTFSC  03.0
059D:  GOTO   5A7
....................             s[cnt]+=0x7; 
059E:  MOVF   43,W
059F:  ADDWF  3B,W
05A0:  MOVWF  04
05A1:  BCF    03.7
05A2:  BTFSC  3C.0
05A3:  BSF    03.7
05A4:  MOVLW  07
05A5:  ADDWF  00,W
05A6:  MOVWF  00
....................  
....................          cnt++; 
05A7:  INCF   43,F
....................          num=temp; 
05A8:  MOVF   40,W
05A9:  MOVWF  39
05AA:  MOVF   3F,W
05AB:  MOVWF  38
05AC:  MOVF   3E,W
05AD:  MOVWF  37
05AE:  MOVF   3D,W
05AF:  MOVWF  36
05B0:  GOTO   529
....................      } 
....................  
....................      if(sign==1) { 
05B1:  DECFSZ 42,W
05B2:  GOTO   5BC
....................          s[cnt]=0x2D;      // Negative sign 
05B3:  MOVF   43,W
05B4:  ADDWF  3B,W
05B5:  MOVWF  04
05B6:  BCF    03.7
05B7:  BTFSC  3C.0
05B8:  BSF    03.7
05B9:  MOVLW  2D
05BA:  MOVWF  00
....................          cnt++; 
05BB:  INCF   43,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
05BC:  CLRF   41
05BD:  BCF    03.0
05BE:  RRF    43,W
05BF:  SUBWF  41,W
05C0:  BTFSC  03.0
05C1:  GOTO   5F2
....................  
....................          c=s[i]; 
05C2:  MOVF   41,W
05C3:  ADDWF  3B,W
05C4:  MOVWF  04
05C5:  BCF    03.7
05C6:  BTFSC  3C.0
05C7:  BSF    03.7
05C8:  MOVF   00,W
05C9:  MOVWF  44
....................          s[i]=s[cnt-i-1];        // Reverse the number 
05CA:  MOVF   41,W
05CB:  ADDWF  3B,W
05CC:  MOVWF  78
05CD:  MOVF   3C,W
05CE:  MOVWF  7A
05CF:  BTFSC  03.0
05D0:  INCF   7A,F
05D1:  MOVF   78,W
05D2:  MOVWF  45
05D3:  MOVF   7A,W
05D4:  MOVWF  46
05D5:  MOVF   41,W
05D6:  SUBWF  43,W
05D7:  ADDLW  FF
05D8:  ADDWF  3B,W
05D9:  MOVWF  04
05DA:  BCF    03.7
05DB:  BTFSC  3C.0
05DC:  BSF    03.7
05DD:  MOVF   00,W
05DE:  MOVWF  47
05DF:  MOVF   45,W
05E0:  MOVWF  04
05E1:  BCF    03.7
05E2:  BTFSC  46.0
05E3:  BSF    03.7
05E4:  MOVF   47,W
05E5:  MOVWF  00
....................          s[cnt-i-1]=c; 
05E6:  MOVF   41,W
05E7:  SUBWF  43,W
05E8:  ADDLW  FF
05E9:  ADDWF  3B,W
05EA:  MOVWF  04
05EB:  BCF    03.7
05EC:  BTFSC  3C.0
05ED:  BSF    03.7
05EE:  MOVF   44,W
05EF:  MOVWF  00
05F0:  INCF   41,F
05F1:  GOTO   5BD
....................      } 
....................      s[cnt]='\0';     // End the string 
05F2:  MOVF   43,W
05F3:  ADDWF  3B,W
05F4:  MOVWF  04
05F5:  BCF    03.7
05F6:  BTFSC  3C.0
05F7:  BSF    03.7
05F8:  CLRF   00
....................      return s; 
05F9:  MOVF   3B,W
05FA:  MOVWF  78
05FB:  MOVF   3C,W
05FC:  MOVWF  79
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //#include <main.h> 
.................... #use FAST_IO(E) 
.................... #use FAST_IO(D) 
.................... #define LCD_RS PIN_E0                         
.................... #define LCD_RW PIN_E1 
.................... #define LCD_EN PIN_E2 
.................... #define LCD_D4 PIN_D4                  
.................... #define LCD_D5 PIN_D5 
.................... #define LCD_D6 PIN_D6 
.................... #define LCD_D7 PIN_D7  
....................  
.................... #include "lcd.c" 
.................... /** 
....................   ****************************************************************************** 
....................   * Ten Tep      :        lcd_16x2.c 
....................   * Tac Gia      :        Nguyen Quy Nhat 
....................   * Cong Ty      :        MinhHaGroup 
....................   * Website      :        BanLinhKien.Vn 
....................   * Phien Ban    :        V1.0.0 
....................   * Ngay         :        31-07-2012 
....................   * Tom Tat      :        Dinh nghia cac ham dieu khien LCD 16x2. 
....................   *            
....................   * 
....................   ****************************************************************************** 
....................   * Chu Y        :   Phai dinh nghia cac chan su dung cho LCD vao ham main.h 
....................   *                       
....................   ****************************************************************************** 
....................   */ 
.................... //Tao Xung 
....................  void LCD_Enable(void) 
.................... { 
....................  output_high(LCD_EN); 
*
02A2:  BSF    09.2
....................  delay_us(3); 
02A3:  GOTO   2A4
02A4:  GOTO   2A5
02A5:  GOTO   2A6
....................  output_low(LCD_EN); 
02A6:  BCF    09.2
....................  delay_us(50);  
02A7:  MOVLW  20
02A8:  MOVWF  77
02A9:  DECFSZ 77,F
02AA:  GOTO   2A9
02AB:  GOTO   2AC
02AC:  NOP
02AD:  RETURN
.................... } 
.................... //Ham Gui 4 Bit Du Lieu Ra LCD 
....................  void LCD_Send4Bit( unsigned char Data ) 
.................... { 
....................  output_bit(LCD_D4,Data&0x01); 
*
026B:  BSF    03.5
026C:  BTFSC  3C.0
026D:  GOTO   272
026E:  BCF    03.5
026F:  BCF    08.4
0270:  GOTO   274
0271:  BSF    03.5
0272:  BCF    03.5
0273:  BSF    08.4
....................  output_bit(LCD_D5,(Data>>1)&1); 
0274:  BCF    03.0
0275:  BSF    03.5
0276:  RRF    3C,W
0277:  ANDLW  01
0278:  BTFSS  03.2
0279:  GOTO   27E
027A:  BCF    03.5
027B:  BCF    08.5
027C:  GOTO   280
027D:  BSF    03.5
027E:  BCF    03.5
027F:  BSF    08.5
....................  output_bit(LCD_D6,(Data>>2)&1); 
0280:  BSF    03.5
0281:  RRF    3C,W
0282:  MOVWF  77
0283:  RRF    77,F
0284:  MOVLW  3F
0285:  ANDWF  77,F
0286:  MOVF   77,W
0287:  ANDLW  01
0288:  BTFSS  03.2
0289:  GOTO   28E
028A:  BCF    03.5
028B:  BCF    08.6
028C:  GOTO   290
028D:  BSF    03.5
028E:  BCF    03.5
028F:  BSF    08.6
....................  output_bit(LCD_D7,(Data>>3)&1); 
0290:  BSF    03.5
0291:  RRF    3C,W
0292:  MOVWF  77
0293:  RRF    77,F
0294:  RRF    77,F
0295:  MOVLW  1F
0296:  ANDWF  77,F
0297:  MOVF   77,W
0298:  ANDLW  01
0299:  BTFSS  03.2
029A:  GOTO   29F
029B:  BCF    03.5
029C:  BCF    08.7
029D:  GOTO   2A1
029E:  BSF    03.5
029F:  BCF    03.5
02A0:  BSF    08.7
02A1:  RETURN
.................... } 
.................... // Ham Gui 1 Lenh Cho LCD 
....................  void LCD_SendCommand (unsigned char command ) 
.................... { 
.................... LCD_Send4Bit  ( command >>4 );/* Gui 4 bit cao */ 
*
02AE:  BSF    03.5
02AF:  SWAPF  3A,W
02B0:  MOVWF  3B
02B1:  MOVLW  0F
02B2:  ANDWF  3B,F
02B3:  MOVF   3B,W
02B4:  MOVWF  3C
02B5:  BCF    03.5
02B6:  CALL   26B
.................... LCD_Enable () ; 
02B7:  CALL   2A2
.................... LCD_Send4Bit  ( command  );      /* Gui 4 bit thap*/ 
02B8:  BSF    03.5
02B9:  MOVF   3A,W
02BA:  MOVWF  3C
02BB:  BCF    03.5
02BC:  CALL   26B
.................... LCD_Enable () ; 
02BD:  CALL   2A2
02BE:  RETURN
.................... } 
.................... // Ham Khoi Tao LCD 
....................  void LCD_Init ( void ) 
.................... { 
.................... output_drive(LCD_D4); 
*
0828:  BSF    03.5
0829:  BCF    08.4
.................... output_drive(LCD_D5); 
082A:  BCF    08.5
.................... output_drive(LCD_D6); 
082B:  BCF    08.6
.................... output_drive(LCD_D7); 
082C:  BCF    08.7
.................... output_drive(LCD_EN); 
082D:  BCF    09.2
.................... output_drive(LCD_RS); 
082E:  BCF    09.0
.................... output_drive(LCD_RW); 
082F:  BCF    09.1
0830:  BCF    03.5
0831:  CLRF   27
0832:  BTFSC  0B.7
0833:  BSF    27.7
0834:  BCF    0B.7
.................... LCD_Send4Bit(0x00); 
0835:  BSF    03.5
0836:  CLRF   3C
0837:  BCF    0A.3
0838:  BCF    03.5
0839:  CALL   26B
083A:  BSF    0A.3
083B:  BTFSC  27.7
083C:  BSF    0B.7
083D:  CLRF   27
083E:  BTFSC  0B.7
083F:  BSF    27.7
0840:  BCF    0B.7
.................... delay_ms(20); 
0841:  MOVLW  14
0842:  BSF    03.5
0843:  MOVWF  39
0844:  BCF    0A.3
0845:  BCF    03.5
0846:  CALL   257
0847:  BSF    0A.3
0848:  BTFSC  27.7
0849:  BSF    0B.7
.................... output_low(LCD_RS); 
084A:  BCF    09.0
.................... output_low(LCD_RW); 
084B:  BCF    09.1
084C:  CLRF   27
084D:  BTFSC  0B.7
084E:  BSF    27.7
084F:  BCF    0B.7
.................... LCD_Send4Bit(0x03); 
0850:  MOVLW  03
0851:  BSF    03.5
0852:  MOVWF  3C
0853:  BCF    0A.3
0854:  BCF    03.5
0855:  CALL   26B
0856:  BSF    0A.3
0857:  BTFSC  27.7
0858:  BSF    0B.7
.................... LCD_Enable(); 
0859:  BCF    0A.3
085A:  CALL   2A2
085B:  BSF    0A.3
085C:  CLRF   27
085D:  BTFSC  0B.7
085E:  BSF    27.7
085F:  BCF    0B.7
.................... delay_ms(5); 
0860:  MOVLW  05
0861:  BSF    03.5
0862:  MOVWF  39
0863:  BCF    0A.3
0864:  BCF    03.5
0865:  CALL   257
0866:  BSF    0A.3
0867:  BTFSC  27.7
0868:  BSF    0B.7
.................... LCD_Enable(); 
0869:  BCF    0A.3
086A:  CALL   2A2
086B:  BSF    0A.3
.................... delay_us(100); 
086C:  MOVLW  42
086D:  MOVWF  77
086E:  DECFSZ 77,F
086F:  GOTO   06E
0870:  NOP
.................... LCD_Enable(); 
0871:  BCF    0A.3
0872:  CALL   2A2
0873:  BSF    0A.3
0874:  CLRF   27
0875:  BTFSC  0B.7
0876:  BSF    27.7
0877:  BCF    0B.7
.................... LCD_Send4Bit(0x02); 
0878:  MOVLW  02
0879:  BSF    03.5
087A:  MOVWF  3C
087B:  BCF    0A.3
087C:  BCF    03.5
087D:  CALL   26B
087E:  BSF    0A.3
087F:  BTFSC  27.7
0880:  BSF    0B.7
.................... LCD_Enable(); 
0881:  BCF    0A.3
0882:  CALL   2A2
0883:  BSF    0A.3
0884:  CLRF   27
0885:  BTFSC  0B.7
0886:  BSF    27.7
0887:  BCF    0B.7
.................... LCD_SendCommand( 0x28 );      // giao thuc 4 bit, hien thi 2 hang, ki tu 5x8 
0888:  MOVLW  28
0889:  BSF    03.5
088A:  MOVWF  3A
088B:  BCF    0A.3
088C:  BCF    03.5
088D:  CALL   2AE
088E:  BSF    0A.3
088F:  BTFSC  27.7
0890:  BSF    0B.7
0891:  CLRF   27
0892:  BTFSC  0B.7
0893:  BSF    27.7
0894:  BCF    0B.7
.................... LCD_SendCommand( 0x0c);    // cho phep hien thi man hinh 
0895:  MOVLW  0C
0896:  BSF    03.5
0897:  MOVWF  3A
0898:  BCF    0A.3
0899:  BCF    03.5
089A:  CALL   2AE
089B:  BSF    0A.3
089C:  BTFSC  27.7
089D:  BSF    0B.7
089E:  CLRF   27
089F:  BTFSC  0B.7
08A0:  BSF    27.7
08A1:  BCF    0B.7
.................... LCD_SendCommand( 0x06 );      // tang ID, khong dich khung hinh 
08A2:  MOVLW  06
08A3:  BSF    03.5
08A4:  MOVWF  3A
08A5:  BCF    0A.3
08A6:  BCF    03.5
08A7:  CALL   2AE
08A8:  BSF    0A.3
08A9:  BTFSC  27.7
08AA:  BSF    0B.7
08AB:  CLRF   27
08AC:  BTFSC  0B.7
08AD:  BSF    27.7
08AE:  BCF    0B.7
.................... LCD_SendCommand( 0x01 ); // xoa toan bo khung hinh 
08AF:  MOVLW  01
08B0:  BSF    03.5
08B1:  MOVWF  3A
08B2:  BCF    0A.3
08B3:  BCF    03.5
08B4:  CALL   2AE
08B5:  BSF    0A.3
08B6:  BTFSC  27.7
08B7:  BSF    0B.7
08B8:  BSF    0A.3
08B9:  BCF    0A.4
08BA:  GOTO   1C4 (RETURN)
.................... } 
.................... void LCD_Gotoxy(unsigned char x, unsigned char y) 
.................... { 
....................   unsigned char address; 
....................   if(!y) 
*
0629:  MOVF   37,F
062A:  BTFSS  03.2
062B:  GOTO   630
....................   address = (0x80+x); 
062C:  MOVLW  80
062D:  ADDWF  36,W
062E:  MOVWF  38
062F:  GOTO   633
....................   else 
....................   address = (0xC0+x); 
0630:  MOVLW  C0
0631:  ADDWF  36,W
0632:  MOVWF  38
....................   delay_us(1000); 
0633:  MOVLW  01
0634:  MOVWF  39
0635:  BCF    03.5
0636:  CALL   257
....................   LCD_SendCommand(address); 
0637:  BSF    03.5
0638:  MOVF   38,W
0639:  MOVWF  3A
063A:  BCF    03.5
063B:  CALL   2AE
....................   delay_us(50); 
063C:  MOVLW  20
063D:  MOVWF  77
063E:  DECFSZ 77,F
063F:  GOTO   63E
0640:  GOTO   641
0641:  NOP
.................... } 
.................... // Ham Xoa Man Hinh LCD 
.................... void LCD_Clear() 
.................... { 
....................   LCD_SendCommand(0x01);   
....................   delay_ms(10); 
.................... } 
.................... // Ham Gui 1 Ki Tu Len LCD 
....................  void LCD_PutChar ( unsigned char Data ) 
.................... { 
....................  output_high(LCD_RS); 
*
065B:  BCF    03.5
065C:  BSF    09.0
....................  LCD_SendCommand( Data ); 
065D:  BSF    03.5
065E:  MOVF   39,W
065F:  MOVWF  3A
0660:  BCF    03.5
0661:  CALL   2AE
....................  output_low(LCD_RS); 
0662:  BCF    09.0
.................... } 
.................... void LCD_Puts (char *s) 
.................... { 
....................    while (*s) 
*
0646:  MOVF   37,W
0647:  MOVWF  7A
0648:  MOVF   36,W
0649:  MOVWF  04
064A:  BCF    03.7
064B:  BTFSC  7A.0
064C:  BSF    03.7
064D:  MOVF   00,F
064E:  BTFSC  03.2
064F:  GOTO   668
....................    { 
....................       LCD_PutChar(*s); 
0650:  MOVF   37,W
0651:  MOVWF  7A
0652:  MOVF   36,W
0653:  MOVWF  04
0654:  BCF    03.7
0655:  BTFSC  7A.0
0656:  BSF    03.7
0657:  MOVF   00,W
0658:  MOVWF  38
0659:  MOVF   38,W
065A:  MOVWF  39
....................       s++; 
*
0663:  BSF    03.5
0664:  INCF   36,F
0665:  BTFSC  03.2
0666:  INCF   37,F
0667:  GOTO   646
....................    } 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include <var.h> 
.................... #ifndef _VAR_ 
.................... #define _VAR_ 
....................    //const unsigned char  chu_so[10] = {0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90}; 
....................    //gia tri tren led 7 thanh          0  1     2    3     4    5   6     7   8    9 
....................    //const unsigned char OFF_LED=0xff; 
....................    //unsigned char buffer[3]; 
.................... #endif                                           
....................  
....................  
.................... int8 a=0; 
.................... int16 time=0,xung_thuc_te,v; 
.................... int16 tocdo=0; 
.................... float Kp,Ki,Kd,T,a0,a1,a2,e,e1=0,e2=0,u,u1=0; 
.................... int8 do_rong_xung; 
.................... char b[3], c[4]; 
.................... int8 str[4]; 
.................... // PHAN THIET LAP TOC DO QUAY CUA DONG CO 
....................  
.................... #INT_RDA 
.................... void ngat_RS232() 
*
007F:  BSF    03.5
0080:  CLRF   36
.................... { 
....................  int8 i=0; 
....................    for(i=0;i<2;i++) 
0081:  CLRF   36
0082:  MOVF   36,W
0083:  SUBLW  01
0084:  BTFSS  03.0
0085:  GOTO   092
....................    { 
....................     b[i]=getc(); 
0086:  MOVLW  68
0087:  ADDWF  36,W
0088:  MOVWF  04
0089:  BCF    03.7
008A:  BCF    03.5
008B:  BTFSS  0C.5
008C:  GOTO   08B
008D:  MOVF   1A,W
008E:  MOVWF  00
008F:  BSF    03.5
0090:  INCF   36,F
0091:  GOTO   082
....................    }  
.................... tocdo=atoi(b); 
0092:  CLRF   38
0093:  MOVLW  68
0094:  MOVWF  37
*
0194:  CLRF   7A
0195:  MOVF   78,W
0196:  BCF    03.5
0197:  MOVWF  35
0198:  MOVF   7A,W
0199:  MOVWF  36
.................... xung_thuc_te=(tocdo*41)/600;//Tinh Xung Thuc Te Chay Trong41ms 
019A:  MOVF   36,W
019B:  BSF    03.5
019C:  MOVWF  38
019D:  BCF    03.5
019E:  MOVF   35,W
019F:  BSF    03.5
01A0:  MOVWF  37
01A1:  CLRF   3A
01A2:  MOVLW  29
01A3:  MOVWF  39
01A4:  BCF    03.5
01A5:  CALL   041
01A6:  MOVF   79,W
01A7:  BSF    03.5
01A8:  MOVWF  38
01A9:  MOVF   78,W
01AA:  MOVWF  37
01AB:  MOVF   38,W
01AC:  MOVWF  3A
01AD:  MOVF   37,W
01AE:  MOVWF  39
01AF:  MOVLW  02
01B0:  MOVWF  3C
01B1:  MOVLW  58
01B2:  MOVWF  3B
01B3:  BCF    03.5
01B4:  CALL   058
01B5:  MOVF   79,W
01B6:  MOVWF  32
01B7:  MOVF   78,W
01B8:  MOVWF  31
.................... if(xung_thuc_te==0) 
01B9:  MOVF   31,F
01BA:  BTFSS  03.2
01BB:  GOTO   1CE
01BC:  MOVF   32,F
01BD:  BTFSS  03.2
01BE:  GOTO   1CE
....................   { 
....................   set_pwm1_duty(0); 
01BF:  CLRF   15
....................   a=0; e=0 ;e1=0; e2=0; 
01C0:  CLRF   2E
01C1:  CLRF   56
01C2:  CLRF   55
01C3:  CLRF   54
01C4:  CLRF   53
01C5:  CLRF   5A
01C6:  CLRF   59
01C7:  CLRF   58
01C8:  CLRF   57
01C9:  CLRF   5E
01CA:  CLRF   5D
01CB:  CLRF   5C
01CC:  CLRF   5B
....................   } 
01CD:  GOTO   1D4
.................... else 
....................    { 
....................    set_pwm1_duty(125); 
01CE:  MOVLW  7D
01CF:  MOVWF  15
....................    enable_interrupts(INT_CCP2); 
01D0:  BSF    03.5
01D1:  BSF    0D.0
....................    enable_interrupts(INT_RTCC); 
01D2:  BCF    03.5
01D3:  BSF    0B.5
....................    } 
....................    disable_interrupts(INT_RDA); 
01D4:  BSF    03.5
01D5:  BCF    0C.5
.................... } 
....................  
01D6:  BCF    03.5
01D7:  BCF    0C.5
01D8:  BCF    0A.3
01D9:  BCF    0A.4
01DA:  GOTO   027
.................... #INT_RTCC 
.................... void ngat_timer0() 
.................... { 
.................... time=time+1; 
*
04BD:  MOVLW  01
04BE:  ADDWF  2F,F
04BF:  BTFSC  03.0
04C0:  INCF   30,F
.................... //set_timer0(5); 
....................  
.................... if(time==20) 
04C1:  MOVF   2F,W
04C2:  SUBLW  14
04C3:  BTFSS  03.2
04C4:  GOTO   7F5
04C5:  MOVF   30,F
04C6:  BTFSS  03.2
04C7:  GOTO   7F5
.................... { 
.................... if(a==5) 
04C8:  MOVF   2E,W
04C9:  SUBLW  05
04CA:  BTFSS  03.2
04CB:  GOTO   4D0
....................  output_high(pin_B0); 
04CC:  BSF    03.5
04CD:  BCF    06.0
04CE:  BCF    03.5
04CF:  BSF    06.0
....................   
.................... itoa(v,10,c); 
04D0:  BSF    03.5
04D1:  CLRF   39
04D2:  CLRF   38
04D3:  BCF    03.5
04D4:  MOVF   34,W
04D5:  BSF    03.5
04D6:  MOVWF  37
04D7:  BCF    03.5
04D8:  MOVF   33,W
04D9:  BSF    03.5
04DA:  MOVWF  36
04DB:  MOVLW  0A
04DC:  MOVWF  3A
04DD:  CLRF   3C
04DE:  MOVLW  6B
04DF:  MOVWF  3B
.................... sprintf(str,c); 
*
05FD:  CLRF   74
05FE:  MOVLW  6F
05FF:  MOVWF  73
0600:  MOVLW  6B
0601:  MOVWF  04
0602:  BCF    03.7
.................... LCD_Gotoxy(1,0); 
*
0626:  MOVLW  01
0627:  MOVWF  36
0628:  CLRF   37
.................... LCD_puts(str); 
*
0642:  BSF    03.5
0643:  CLRF   37
0644:  MOVLW  6F
0645:  MOVWF  36
.................... e=a-xung_thuc_te; 
*
0668:  BCF    03.5
0669:  MOVF   31,W
066A:  SUBWF  2E,W
066B:  MOVWF  77
066C:  CLRF   7A
066D:  MOVF   32,W
066E:  BTFSS  03.0
066F:  INCFSZ 32,W
0670:  SUBWF  7A,F
0671:  MOVF   77,W
0672:  BSF    03.5
0673:  MOVWF  36
0674:  MOVF   7A,W
0675:  MOVWF  37
*
0692:  MOVF   7A,W
0693:  BCF    03.5
0694:  MOVWF  56
0695:  MOVF   79,W
0696:  MOVWF  55
0697:  MOVF   78,W
0698:  MOVWF  54
0699:  MOVF   77,W
069A:  MOVWF  53
.................... u=u1+a0*e+a1*e1+a2*e2; 
069B:  MOVF   4A,W
069C:  BSF    03.5
069D:  MOVWF  3D
069E:  BCF    03.5
069F:  MOVF   49,W
06A0:  BSF    03.5
06A1:  MOVWF  3C
06A2:  BCF    03.5
06A3:  MOVF   48,W
06A4:  BSF    03.5
06A5:  MOVWF  3B
06A6:  BCF    03.5
06A7:  MOVF   47,W
06A8:  BSF    03.5
06A9:  MOVWF  3A
06AA:  BCF    03.5
06AB:  MOVF   56,W
06AC:  BSF    03.5
06AD:  MOVWF  41
06AE:  BCF    03.5
06AF:  MOVF   55,W
06B0:  BSF    03.5
06B1:  MOVWF  40
06B2:  BCF    03.5
06B3:  MOVF   54,W
06B4:  BSF    03.5
06B5:  MOVWF  3F
06B6:  BCF    03.5
06B7:  MOVF   53,W
06B8:  BSF    03.5
06B9:  MOVWF  3E
06BA:  BCF    03.5
06BB:  CALL   2BF
06BC:  BCF    03.1
06BD:  MOVF   66,W
06BE:  BSF    03.5
06BF:  MOVWF  3D
06C0:  BCF    03.5
06C1:  MOVF   65,W
06C2:  BSF    03.5
06C3:  MOVWF  3C
06C4:  BCF    03.5
06C5:  MOVF   64,W
06C6:  BSF    03.5
06C7:  MOVWF  3B
06C8:  BCF    03.5
06C9:  MOVF   63,W
06CA:  BSF    03.5
06CB:  MOVWF  3A
06CC:  MOVF   7A,W
06CD:  MOVWF  41
06CE:  MOVF   79,W
06CF:  MOVWF  40
06D0:  MOVF   78,W
06D1:  MOVWF  3F
06D2:  MOVF   77,W
06D3:  MOVWF  3E
06D4:  BCF    03.5
06D5:  CALL   336
06D6:  MOVF   7A,W
06D7:  BSF    03.5
06D8:  MOVWF  39
06D9:  MOVF   79,W
06DA:  MOVWF  38
06DB:  MOVF   78,W
06DC:  MOVWF  37
06DD:  MOVF   77,W
06DE:  MOVWF  36
06DF:  BCF    03.5
06E0:  MOVF   4E,W
06E1:  BSF    03.5
06E2:  MOVWF  3D
06E3:  BCF    03.5
06E4:  MOVF   4D,W
06E5:  BSF    03.5
06E6:  MOVWF  3C
06E7:  BCF    03.5
06E8:  MOVF   4C,W
06E9:  BSF    03.5
06EA:  MOVWF  3B
06EB:  BCF    03.5
06EC:  MOVF   4B,W
06ED:  BSF    03.5
06EE:  MOVWF  3A
06EF:  BCF    03.5
06F0:  MOVF   5A,W
06F1:  BSF    03.5
06F2:  MOVWF  41
06F3:  BCF    03.5
06F4:  MOVF   59,W
06F5:  BSF    03.5
06F6:  MOVWF  40
06F7:  BCF    03.5
06F8:  MOVF   58,W
06F9:  BSF    03.5
06FA:  MOVWF  3F
06FB:  BCF    03.5
06FC:  MOVF   57,W
06FD:  BSF    03.5
06FE:  MOVWF  3E
06FF:  BCF    03.5
0700:  CALL   2BF
0701:  BCF    03.1
0702:  BSF    03.5
0703:  MOVF   39,W
0704:  MOVWF  3D
0705:  MOVF   38,W
0706:  MOVWF  3C
0707:  MOVF   37,W
0708:  MOVWF  3B
0709:  MOVF   36,W
070A:  MOVWF  3A
070B:  MOVF   7A,W
070C:  MOVWF  41
070D:  MOVF   79,W
070E:  MOVWF  40
070F:  MOVF   78,W
0710:  MOVWF  3F
0711:  MOVF   77,W
0712:  MOVWF  3E
0713:  BCF    03.5
0714:  CALL   336
0715:  MOVF   7A,W
0716:  BSF    03.5
0717:  MOVWF  39
0718:  MOVF   79,W
0719:  MOVWF  38
071A:  MOVF   78,W
071B:  MOVWF  37
071C:  MOVF   77,W
071D:  MOVWF  36
071E:  BCF    03.5
071F:  MOVF   52,W
0720:  BSF    03.5
0721:  MOVWF  3D
0722:  BCF    03.5
0723:  MOVF   51,W
0724:  BSF    03.5
0725:  MOVWF  3C
0726:  BCF    03.5
0727:  MOVF   50,W
0728:  BSF    03.5
0729:  MOVWF  3B
072A:  BCF    03.5
072B:  MOVF   4F,W
072C:  BSF    03.5
072D:  MOVWF  3A
072E:  BCF    03.5
072F:  MOVF   5E,W
0730:  BSF    03.5
0731:  MOVWF  41
0732:  BCF    03.5
0733:  MOVF   5D,W
0734:  BSF    03.5
0735:  MOVWF  40
0736:  BCF    03.5
0737:  MOVF   5C,W
0738:  BSF    03.5
0739:  MOVWF  3F
073A:  BCF    03.5
073B:  MOVF   5B,W
073C:  BSF    03.5
073D:  MOVWF  3E
073E:  BCF    03.5
073F:  CALL   2BF
0740:  BCF    03.1
0741:  BSF    03.5
0742:  MOVF   39,W
0743:  MOVWF  3D
0744:  MOVF   38,W
0745:  MOVWF  3C
0746:  MOVF   37,W
0747:  MOVWF  3B
0748:  MOVF   36,W
0749:  MOVWF  3A
074A:  MOVF   7A,W
074B:  MOVWF  41
074C:  MOVF   79,W
074D:  MOVWF  40
074E:  MOVF   78,W
074F:  MOVWF  3F
0750:  MOVF   77,W
0751:  MOVWF  3E
0752:  BCF    03.5
0753:  CALL   336
0754:  MOVF   7A,W
0755:  MOVWF  62
0756:  MOVF   79,W
0757:  MOVWF  61
0758:  MOVF   78,W
0759:  MOVWF  60
075A:  MOVF   77,W
075B:  MOVWF  5F
.................... u1=u; 
075C:  MOVF   62,W
075D:  MOVWF  66
075E:  MOVF   61,W
075F:  MOVWF  65
0760:  MOVF   60,W
0761:  MOVWF  64
0762:  MOVF   5F,W
0763:  MOVWF  63
.................... e2=e1; 
0764:  MOVF   5A,W
0765:  MOVWF  5E
0766:  MOVF   59,W
0767:  MOVWF  5D
0768:  MOVF   58,W
0769:  MOVWF  5C
076A:  MOVF   57,W
076B:  MOVWF  5B
.................... e1=e; 
076C:  MOVF   56,W
076D:  MOVWF  5A
076E:  MOVF   55,W
076F:  MOVWF  59
0770:  MOVF   54,W
0771:  MOVWF  58
0772:  MOVF   53,W
0773:  MOVWF  57
.................... if(u<=0) 
0774:  MOVF   62,W
0775:  BSF    03.5
0776:  MOVWF  39
0777:  BCF    03.5
0778:  MOVF   61,W
0779:  BSF    03.5
077A:  MOVWF  38
077B:  BCF    03.5
077C:  MOVF   60,W
077D:  BSF    03.5
077E:  MOVWF  37
077F:  BCF    03.5
0780:  MOVF   5F,W
0781:  BSF    03.5
0782:  MOVWF  36
0783:  CLRF   3D
0784:  CLRF   3C
0785:  CLRF   3B
0786:  CLRF   3A
0787:  BCF    03.5
0788:  CALL   47C
0789:  BTFSC  03.0
078A:  GOTO   78D
078B:  BTFSS  03.2
078C:  GOTO   78F
.................... { 
.................... do_rong_xung=0; 
078D:  CLRF   67
.................... } 
078E:  GOTO   7F0
.................... else if(u>=20) 
078F:  BSF    03.5
0790:  CLRF   39
0791:  CLRF   38
0792:  MOVLW  20
0793:  MOVWF  37
0794:  MOVLW  83
0795:  MOVWF  36
0796:  BCF    03.5
0797:  MOVF   62,W
0798:  BSF    03.5
0799:  MOVWF  3D
079A:  BCF    03.5
079B:  MOVF   61,W
079C:  BSF    03.5
079D:  MOVWF  3C
079E:  BCF    03.5
079F:  MOVF   60,W
07A0:  BSF    03.5
07A1:  MOVWF  3B
07A2:  BCF    03.5
07A3:  MOVF   5F,W
07A4:  BSF    03.5
07A5:  MOVWF  3A
07A6:  BCF    03.5
07A7:  CALL   47C
07A8:  BTFSC  03.0
07A9:  GOTO   7AC
07AA:  BTFSS  03.2
07AB:  GOTO   7AF
.................... { 
.................... do_rong_xung=250; 
07AC:  MOVLW  FA
07AD:  MOVWF  67
.................... } 
07AE:  GOTO   7F0
.................... else 
.................... { 
.................... do_rong_xung=(int8)(u*12.5); 
07AF:  MOVF   62,W
07B0:  BSF    03.5
07B1:  MOVWF  3D
07B2:  BCF    03.5
07B3:  MOVF   61,W
07B4:  BSF    03.5
07B5:  MOVWF  3C
07B6:  BCF    03.5
07B7:  MOVF   60,W
07B8:  BSF    03.5
07B9:  MOVWF  3B
07BA:  BCF    03.5
07BB:  MOVF   5F,W
07BC:  BSF    03.5
07BD:  MOVWF  3A
07BE:  CLRF   41
07BF:  CLRF   40
07C0:  MOVLW  48
07C1:  MOVWF  3F
07C2:  MOVLW  82
07C3:  MOVWF  3E
07C4:  BCF    03.5
07C5:  CALL   2BF
07C6:  MOVF   7A,W
07C7:  BSF    03.5
07C8:  MOVWF  39
07C9:  MOVF   79,W
07CA:  MOVWF  38
07CB:  MOVF   78,W
07CC:  MOVWF  37
07CD:  MOVF   77,W
07CE:  MOVWF  36
*
07ED:  MOVF   78,W
07EE:  BCF    03.5
07EF:  MOVWF  67
.................... } 
.................... set_pwm1_duty(do_rong_xung); 
07F0:  MOVF   67,W
07F1:  MOVWF  15
.................... a=0; 
07F2:  CLRF   2E
.................... time=0; 
07F3:  CLRF   30
07F4:  CLRF   2F
.................... } 
.................... } 
....................  
....................  
07F5:  BCF    0B.2
07F6:  BCF    0A.3
07F7:  BCF    0A.4
07F8:  GOTO   027
.................... #INT_CCP2 
.................... void ngat_CCP2() 
.................... { 
.................... a=a+1; 
*
0800:  MOVLW  01
0801:  ADDWF  2E,F
.................... v=(a*600)/41; 
0802:  BSF    03.5
0803:  CLRF   38
0804:  BCF    03.5
0805:  MOVF   2E,W
0806:  BSF    03.5
0807:  MOVWF  37
0808:  MOVLW  02
0809:  MOVWF  3A
080A:  MOVLW  58
080B:  MOVWF  39
080C:  BCF    0A.3
080D:  BCF    03.5
080E:  CALL   041
080F:  BSF    0A.3
0810:  MOVF   79,W
0811:  BSF    03.5
0812:  MOVWF  37
0813:  MOVF   78,W
0814:  MOVWF  36
0815:  MOVF   37,W
0816:  MOVWF  3A
0817:  MOVF   36,W
0818:  MOVWF  39
0819:  CLRF   3C
081A:  MOVLW  29
081B:  MOVWF  3B
081C:  BCF    0A.3
081D:  BCF    03.5
081E:  CALL   058
081F:  BSF    0A.3
0820:  MOVF   79,W
0821:  MOVWF  34
0822:  MOVF   78,W
0823:  MOVWF  33
0824:  BCF    0D.0
0825:  BCF    0A.3
0826:  BCF    0A.4
0827:  GOTO   027
.................... } 
....................  
.................... void main() 
*
0987:  MOVF   03,W
0988:  ANDLW  1F
0989:  MOVWF  03
098A:  BSF    03.5
098B:  BSF    03.6
098C:  BCF    07.3
098D:  MOVLW  0C
098E:  BCF    03.6
098F:  MOVWF  19
0990:  MOVLW  A2
0991:  MOVWF  18
0992:  MOVLW  90
0993:  BCF    03.5
0994:  MOVWF  18
0995:  CLRF   2E
0996:  CLRF   30
0997:  CLRF   2F
0998:  CLRF   36
0999:  CLRF   35
099A:  CLRF   5A
099B:  CLRF   59
099C:  CLRF   58
099D:  CLRF   57
099E:  CLRF   5E
099F:  CLRF   5D
09A0:  CLRF   5C
09A1:  CLRF   5B
09A2:  CLRF   66
09A3:  CLRF   65
09A4:  CLRF   64
09A5:  CLRF   63
09A6:  CLRF   74
09A7:  CLRF   73
09A8:  MOVLW  FF
09A9:  MOVWF  75
09AA:  BSF    03.5
09AB:  BSF    03.6
09AC:  MOVF   09,W
09AD:  ANDLW  C0
09AE:  MOVWF  09
09AF:  BCF    03.6
09B0:  BCF    1F.4
09B1:  BCF    1F.5
09B2:  MOVLW  00
09B3:  BSF    03.6
09B4:  MOVWF  08
09B5:  BCF    03.5
09B6:  CLRF   07
09B7:  CLRF   08
09B8:  CLRF   09
09B9:  BCF    03.7
....................  { 
....................  set_tris_B(0b00000010); 
*
09BD:  MOVLW  02
09BE:  BSF    03.5
09BF:  MOVWF  06
....................  output_B(0); 
09C0:  CLRF   06
09C1:  BCF    03.5
09C2:  CLRF   06
....................  LCD_Init(); 
09C3:  GOTO   028
....................    
....................  Kp=0.007; 
09C4:  MOVLW  42
09C5:  MOVWF  3A
09C6:  MOVLW  60
09C7:  MOVWF  39
09C8:  MOVLW  65
09C9:  MOVWF  38
09CA:  MOVLW  77
09CB:  MOVWF  37
....................  Ki=0.0000535; 
09CC:  MOVLW  30
09CD:  MOVWF  3E
09CE:  MOVLW  65
09CF:  MOVWF  3D
09D0:  MOVLW  60
09D1:  MOVWF  3C
09D2:  MOVLW  70
09D3:  MOVWF  3B
....................  Kd=0.000015; 
09D4:  MOVLW  82
09D5:  MOVWF  42
09D6:  MOVLW  A8
09D7:  MOVWF  41
09D8:  MOVLW  7B
09D9:  MOVWF  40
09DA:  MOVLW  6E
09DB:  MOVWF  3F
....................  T=0.1; 
09DC:  MOVLW  CD
09DD:  MOVWF  46
09DE:  MOVLW  CC
09DF:  MOVWF  45
09E0:  MOVLW  4C
09E1:  MOVWF  44
09E2:  MOVLW  7B
09E3:  MOVWF  43
09E4:  CLRF   27
09E5:  BTFSC  0B.7
09E6:  BSF    27.7
09E7:  BCF    0B.7
....................  a0=Kp+(Ki*T)/2+Kd/T; 
09E8:  MOVF   3E,W
09E9:  BSF    03.5
09EA:  MOVWF  3D
09EB:  BCF    03.5
09EC:  MOVF   3D,W
09ED:  BSF    03.5
09EE:  MOVWF  3C
09EF:  BCF    03.5
09F0:  MOVF   3C,W
09F1:  BSF    03.5
09F2:  MOVWF  3B
09F3:  BCF    03.5
09F4:  MOVF   3B,W
09F5:  BSF    03.5
09F6:  MOVWF  3A
09F7:  BCF    03.5
09F8:  MOVF   46,W
09F9:  BSF    03.5
09FA:  MOVWF  41
09FB:  BCF    03.5
09FC:  MOVF   45,W
09FD:  BSF    03.5
09FE:  MOVWF  40
09FF:  BCF    03.5
0A00:  MOVF   44,W
0A01:  BSF    03.5
0A02:  MOVWF  3F
0A03:  BCF    03.5
0A04:  MOVF   43,W
0A05:  BSF    03.5
0A06:  MOVWF  3E
0A07:  BCF    0A.3
0A08:  BCF    03.5
0A09:  CALL   2BF
0A0A:  BSF    0A.3
0A0B:  BTFSC  27.7
0A0C:  BSF    0B.7
0A0D:  MOVF   7A,W
0A0E:  BSF    03.5
0A0F:  MOVWF  23
0A10:  MOVF   79,W
0A11:  MOVWF  22
0A12:  MOVF   78,W
0A13:  MOVWF  21
0A14:  MOVF   77,W
0A15:  MOVWF  20
0A16:  MOVF   23,W
0A17:  MOVWF  2B
0A18:  MOVF   22,W
0A19:  MOVWF  2A
0A1A:  MOVF   21,W
0A1B:  MOVWF  29
0A1C:  MOVF   20,W
0A1D:  MOVWF  28
0A1E:  CLRF   2F
0A1F:  CLRF   2E
0A20:  CLRF   2D
0A21:  MOVLW  80
0A22:  MOVWF  2C
0A23:  BCF    03.5
0A24:  CALL   0BB
0A25:  BCF    03.1
0A26:  CLRF   27
0A27:  BTFSC  0B.7
0A28:  BSF    27.7
0A29:  BCF    0B.7
0A2A:  MOVF   3A,W
0A2B:  BSF    03.5
0A2C:  MOVWF  3D
0A2D:  BCF    03.5
0A2E:  MOVF   39,W
0A2F:  BSF    03.5
0A30:  MOVWF  3C
0A31:  BCF    03.5
0A32:  MOVF   38,W
0A33:  BSF    03.5
0A34:  MOVWF  3B
0A35:  BCF    03.5
0A36:  MOVF   37,W
0A37:  BSF    03.5
0A38:  MOVWF  3A
0A39:  MOVF   7A,W
0A3A:  MOVWF  41
0A3B:  MOVF   79,W
0A3C:  MOVWF  40
0A3D:  MOVF   78,W
0A3E:  MOVWF  3F
0A3F:  MOVF   77,W
0A40:  MOVWF  3E
0A41:  BCF    0A.3
0A42:  BCF    03.5
0A43:  CALL   336
0A44:  BSF    0A.3
0A45:  BTFSC  27.7
0A46:  BSF    0B.7
0A47:  MOVF   7A,W
0A48:  BSF    03.5
0A49:  MOVWF  23
0A4A:  MOVF   79,W
0A4B:  MOVWF  22
0A4C:  MOVF   78,W
0A4D:  MOVWF  21
0A4E:  MOVF   77,W
0A4F:  MOVWF  20
0A50:  BCF    03.5
0A51:  MOVF   42,W
0A52:  BSF    03.5
0A53:  MOVWF  2B
0A54:  BCF    03.5
0A55:  MOVF   41,W
0A56:  BSF    03.5
0A57:  MOVWF  2A
0A58:  BCF    03.5
0A59:  MOVF   40,W
0A5A:  BSF    03.5
0A5B:  MOVWF  29
0A5C:  BCF    03.5
0A5D:  MOVF   3F,W
0A5E:  BSF    03.5
0A5F:  MOVWF  28
0A60:  BCF    03.5
0A61:  MOVF   46,W
0A62:  BSF    03.5
0A63:  MOVWF  2F
0A64:  BCF    03.5
0A65:  MOVF   45,W
0A66:  BSF    03.5
0A67:  MOVWF  2E
0A68:  BCF    03.5
0A69:  MOVF   44,W
0A6A:  BSF    03.5
0A6B:  MOVWF  2D
0A6C:  BCF    03.5
0A6D:  MOVF   43,W
0A6E:  BSF    03.5
0A6F:  MOVWF  2C
0A70:  BCF    03.5
0A71:  CALL   0BB
0A72:  BCF    03.1
0A73:  CLRF   27
0A74:  BTFSC  0B.7
0A75:  BSF    27.7
0A76:  BCF    0B.7
0A77:  BSF    03.5
0A78:  MOVF   23,W
0A79:  MOVWF  3D
0A7A:  MOVF   22,W
0A7B:  MOVWF  3C
0A7C:  MOVF   21,W
0A7D:  MOVWF  3B
0A7E:  MOVF   20,W
0A7F:  MOVWF  3A
0A80:  MOVF   7A,W
0A81:  MOVWF  41
0A82:  MOVF   79,W
0A83:  MOVWF  40
0A84:  MOVF   78,W
0A85:  MOVWF  3F
0A86:  MOVF   77,W
0A87:  MOVWF  3E
0A88:  BCF    0A.3
0A89:  BCF    03.5
0A8A:  CALL   336
0A8B:  BSF    0A.3
0A8C:  BTFSC  27.7
0A8D:  BSF    0B.7
0A8E:  MOVF   7A,W
0A8F:  MOVWF  4A
0A90:  MOVF   79,W
0A91:  MOVWF  49
0A92:  MOVF   78,W
0A93:  MOVWF  48
0A94:  MOVF   77,W
0A95:  MOVWF  47
....................  a1=-Kp+(Ki*T)/2-(2*Kd)/T; 
0A96:  MOVF   37,W
0A97:  BSF    03.5
0A98:  MOVWF  20
0A99:  BCF    03.5
0A9A:  MOVF   38,W
0A9B:  XORLW  80
0A9C:  BSF    03.5
0A9D:  MOVWF  21
0A9E:  BCF    03.5
0A9F:  MOVF   39,W
0AA0:  BSF    03.5
0AA1:  MOVWF  22
0AA2:  BCF    03.5
0AA3:  MOVF   3A,W
0AA4:  BSF    03.5
0AA5:  MOVWF  23
0AA6:  BCF    03.5
0AA7:  CLRF   27
0AA8:  BTFSC  0B.7
0AA9:  BSF    27.7
0AAA:  BCF    0B.7
0AAB:  MOVF   3E,W
0AAC:  BSF    03.5
0AAD:  MOVWF  3D
0AAE:  BCF    03.5
0AAF:  MOVF   3D,W
0AB0:  BSF    03.5
0AB1:  MOVWF  3C
0AB2:  BCF    03.5
0AB3:  MOVF   3C,W
0AB4:  BSF    03.5
0AB5:  MOVWF  3B
0AB6:  BCF    03.5
0AB7:  MOVF   3B,W
0AB8:  BSF    03.5
0AB9:  MOVWF  3A
0ABA:  BCF    03.5
0ABB:  MOVF   46,W
0ABC:  BSF    03.5
0ABD:  MOVWF  41
0ABE:  BCF    03.5
0ABF:  MOVF   45,W
0AC0:  BSF    03.5
0AC1:  MOVWF  40
0AC2:  BCF    03.5
0AC3:  MOVF   44,W
0AC4:  BSF    03.5
0AC5:  MOVWF  3F
0AC6:  BCF    03.5
0AC7:  MOVF   43,W
0AC8:  BSF    03.5
0AC9:  MOVWF  3E
0ACA:  BCF    0A.3
0ACB:  BCF    03.5
0ACC:  CALL   2BF
0ACD:  BSF    0A.3
0ACE:  BTFSC  27.7
0ACF:  BSF    0B.7
0AD0:  MOVF   7A,W
0AD1:  BSF    03.5
0AD2:  MOVWF  27
0AD3:  MOVF   79,W
0AD4:  MOVWF  26
0AD5:  MOVF   78,W
0AD6:  MOVWF  25
0AD7:  MOVF   77,W
0AD8:  MOVWF  24
0AD9:  MOVF   27,W
0ADA:  MOVWF  2B
0ADB:  MOVF   26,W
0ADC:  MOVWF  2A
0ADD:  MOVF   25,W
0ADE:  MOVWF  29
0ADF:  MOVF   24,W
0AE0:  MOVWF  28
0AE1:  CLRF   2F
0AE2:  CLRF   2E
0AE3:  CLRF   2D
0AE4:  MOVLW  80
0AE5:  MOVWF  2C
0AE6:  BCF    03.5
0AE7:  CALL   0BB
0AE8:  BCF    03.1
0AE9:  CLRF   27
0AEA:  BTFSC  0B.7
0AEB:  BSF    27.7
0AEC:  BCF    0B.7
0AED:  BSF    03.5
0AEE:  MOVF   23,W
0AEF:  MOVWF  3D
0AF0:  MOVF   22,W
0AF1:  MOVWF  3C
0AF2:  MOVF   21,W
0AF3:  MOVWF  3B
0AF4:  MOVF   20,W
0AF5:  MOVWF  3A
0AF6:  MOVF   7A,W
0AF7:  MOVWF  41
0AF8:  MOVF   79,W
0AF9:  MOVWF  40
0AFA:  MOVF   78,W
0AFB:  MOVWF  3F
0AFC:  MOVF   77,W
0AFD:  MOVWF  3E
0AFE:  BCF    0A.3
0AFF:  BCF    03.5
0B00:  CALL   336
0B01:  BSF    0A.3
0B02:  BTFSC  27.7
0B03:  BSF    0B.7
0B04:  MOVF   7A,W
0B05:  BSF    03.5
0B06:  MOVWF  23
0B07:  MOVF   79,W
0B08:  MOVWF  22
0B09:  MOVF   78,W
0B0A:  MOVWF  21
0B0B:  MOVF   77,W
0B0C:  MOVWF  20
0B0D:  BCF    03.5
0B0E:  CLRF   27
0B0F:  BTFSC  0B.7
0B10:  BSF    27.7
0B11:  BCF    0B.7
0B12:  BSF    03.5
0B13:  CLRF   3D
0B14:  CLRF   3C
0B15:  CLRF   3B
0B16:  MOVLW  80
0B17:  MOVWF  3A
0B18:  BCF    03.5
0B19:  MOVF   42,W
0B1A:  BSF    03.5
0B1B:  MOVWF  41
0B1C:  BCF    03.5
0B1D:  MOVF   41,W
0B1E:  BSF    03.5
0B1F:  MOVWF  40
0B20:  BCF    03.5
0B21:  MOVF   40,W
0B22:  BSF    03.5
0B23:  MOVWF  3F
0B24:  BCF    03.5
0B25:  MOVF   3F,W
0B26:  BSF    03.5
0B27:  MOVWF  3E
0B28:  BCF    0A.3
0B29:  BCF    03.5
0B2A:  CALL   2BF
0B2B:  BSF    0A.3
0B2C:  BTFSC  27.7
0B2D:  BSF    0B.7
0B2E:  MOVF   7A,W
0B2F:  BSF    03.5
0B30:  MOVWF  27
0B31:  MOVF   79,W
0B32:  MOVWF  26
0B33:  MOVF   78,W
0B34:  MOVWF  25
0B35:  MOVF   77,W
0B36:  MOVWF  24
0B37:  MOVF   27,W
0B38:  MOVWF  2B
0B39:  MOVF   26,W
0B3A:  MOVWF  2A
0B3B:  MOVF   25,W
0B3C:  MOVWF  29
0B3D:  MOVF   24,W
0B3E:  MOVWF  28
0B3F:  BCF    03.5
0B40:  MOVF   46,W
0B41:  BSF    03.5
0B42:  MOVWF  2F
0B43:  BCF    03.5
0B44:  MOVF   45,W
0B45:  BSF    03.5
0B46:  MOVWF  2E
0B47:  BCF    03.5
0B48:  MOVF   44,W
0B49:  BSF    03.5
0B4A:  MOVWF  2D
0B4B:  BCF    03.5
0B4C:  MOVF   43,W
0B4D:  BSF    03.5
0B4E:  MOVWF  2C
0B4F:  BCF    03.5
0B50:  CALL   0BB
0B51:  BSF    03.1
0B52:  CLRF   27
0B53:  BTFSC  0B.7
0B54:  BSF    27.7
0B55:  BCF    0B.7
0B56:  BSF    03.5
0B57:  MOVF   23,W
0B58:  MOVWF  3D
0B59:  MOVF   22,W
0B5A:  MOVWF  3C
0B5B:  MOVF   21,W
0B5C:  MOVWF  3B
0B5D:  MOVF   20,W
0B5E:  MOVWF  3A
0B5F:  MOVF   7A,W
0B60:  MOVWF  41
0B61:  MOVF   79,W
0B62:  MOVWF  40
0B63:  MOVF   78,W
0B64:  MOVWF  3F
0B65:  MOVF   77,W
0B66:  MOVWF  3E
0B67:  BCF    0A.3
0B68:  BCF    03.5
0B69:  CALL   336
0B6A:  BSF    0A.3
0B6B:  BTFSC  27.7
0B6C:  BSF    0B.7
0B6D:  MOVF   7A,W
0B6E:  MOVWF  4E
0B6F:  MOVF   79,W
0B70:  MOVWF  4D
0B71:  MOVF   78,W
0B72:  MOVWF  4C
0B73:  MOVF   77,W
0B74:  MOVWF  4B
....................  a2=Kd/T; 
0B75:  MOVF   42,W
0B76:  BSF    03.5
0B77:  MOVWF  2B
0B78:  BCF    03.5
0B79:  MOVF   41,W
0B7A:  BSF    03.5
0B7B:  MOVWF  2A
0B7C:  BCF    03.5
0B7D:  MOVF   40,W
0B7E:  BSF    03.5
0B7F:  MOVWF  29
0B80:  BCF    03.5
0B81:  MOVF   3F,W
0B82:  BSF    03.5
0B83:  MOVWF  28
0B84:  BCF    03.5
0B85:  MOVF   46,W
0B86:  BSF    03.5
0B87:  MOVWF  2F
0B88:  BCF    03.5
0B89:  MOVF   45,W
0B8A:  BSF    03.5
0B8B:  MOVWF  2E
0B8C:  BCF    03.5
0B8D:  MOVF   44,W
0B8E:  BSF    03.5
0B8F:  MOVWF  2D
0B90:  BCF    03.5
0B91:  MOVF   43,W
0B92:  BSF    03.5
0B93:  MOVWF  2C
0B94:  BCF    03.5
0B95:  CALL   0BB
0B96:  MOVF   7A,W
0B97:  MOVWF  52
0B98:  MOVF   79,W
0B99:  MOVWF  51
0B9A:  MOVF   78,W
0B9B:  MOVWF  50
0B9C:  MOVF   77,W
0B9D:  MOVWF  4F
....................  setup_ccp1(CCP_PWM); 
0B9E:  BCF    75.2
0B9F:  MOVF   75,W
0BA0:  BSF    03.5
0BA1:  MOVWF  07
0BA2:  BCF    03.5
0BA3:  BCF    07.2
0BA4:  MOVLW  0C
0BA5:  MOVWF  17
0BA6:  BSF    03.5
0BA7:  CLRF   1B
0BA8:  CLRF   1C
0BA9:  MOVLW  01
0BAA:  MOVWF  1D
....................  setup_ccp2(CCP_CAPTURE_RE);//  CCP_CAPTURE_DIV_1 
0BAB:  BSF    75.1
0BAC:  MOVF   75,W
0BAD:  MOVWF  07
0BAE:  BCF    03.5
0BAF:  CLRF   1D
0BB0:  MOVLW  05
0BB1:  MOVWF  1D
....................  setup_timer_2(t2_div_by_16,250,1); //tan so xung f=1,245 kHz 
0BB2:  MOVLW  00
0BB3:  MOVWF  78
0BB4:  IORLW  06
0BB5:  MOVWF  12
0BB6:  MOVLW  FA
0BB7:  BSF    03.5
0BB8:  MOVWF  12
....................  set_pwm1_duty(0); 
0BB9:  BCF    03.5
0BBA:  CLRF   15
....................  setup_timer_0(RTCC_INTERNAL|RTCC_DIV_16); // ngat sau 2.04 ms 
0BBB:  BSF    03.5
0BBC:  MOVF   01,W
0BBD:  ANDLW  C0
0BBE:  IORLW  03
0BBF:  MOVWF  01
....................  //set_timer0(255); // 
....................  enable_interrupts(INT_RDA); 
0BC0:  BSF    0C.5
....................  enable_interrupts(GLOBAL); 
0BC1:  MOVLW  C0
0BC2:  BCF    03.5
0BC3:  IORWF  0B,F
....................  
.................... while(true) 
....................     {   
....................     ; 
0BC4:  GOTO   3C4
....................     } 
....................  } 
0BC5:  SLEEP

Configuration Fuses:
   Word  1: 2CF2   HS NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
