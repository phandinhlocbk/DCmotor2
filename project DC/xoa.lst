CCS PCM C Compiler, Version 5.015, 5967               28-Nov-14 00:19

               Filename:   N:\Tai Lieu Hoc Tap Nam 4\Vi dieu khien\project\xoa.lst

               ROM used:   2576 words (31%)
                           Largest free fragment is 2048
               RAM used:   96 (26%) at main() level
                           155 (42%) worst case
               Stack used: 6 locations (3 in main + 3 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  BTFSS  0B.5
0018:  GOTO   01B
0019:  BTFSC  0B.2
001A:  GOTO   036
001B:  BTFSS  0B.4
001C:  GOTO   01F
001D:  BTFSC  0B.1
001E:  GOTO   039
001F:  MOVLW  8D
0020:  MOVWF  04
0021:  BTFSS  00.0
0022:  GOTO   025
0023:  BTFSC  0D.0
0024:  GOTO   03C
0025:  MOVF   22,W
0026:  MOVWF  04
0027:  MOVF   23,W
0028:  MOVWF  77
0029:  MOVF   24,W
002A:  MOVWF  78
002B:  MOVF   25,W
002C:  MOVWF  79
002D:  MOVF   26,W
002E:  MOVWF  7A
002F:  MOVF   20,W
0030:  MOVWF  0A
0031:  SWAPF  21,W
0032:  MOVWF  03
0033:  SWAPF  7F,F
0034:  SWAPF  7F,W
0035:  RETFIE
0036:  BCF    0A.3
0037:  BCF    0A.4
0038:  GOTO   34B
0039:  BCF    0A.3
003A:  BCF    0A.4
003B:  GOTO   03F
003C:  BCF    0A.3
003D:  BCF    0A.4
003E:  GOTO   67E
.................... #include <16f887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
*
0046:  MOVF   37,W
0047:  CLRF   78
0048:  SUBWF  36,W
0049:  BTFSC  03.0
004A:  GOTO   04E
004B:  MOVF   36,W
004C:  MOVWF  77
004D:  GOTO   05A
004E:  CLRF   77
004F:  MOVLW  08
0050:  MOVWF  38
0051:  RLF    36,F
0052:  RLF    77,F
0053:  MOVF   37,W
0054:  SUBWF  77,W
0055:  BTFSC  03.0
0056:  MOVWF  77
0057:  RLF    78,F
0058:  DECFSZ 38,F
0059:  GOTO   051
*
0069:  BTFSC  03.1
006A:  GOTO   06E
006B:  MOVLW  D5
006C:  MOVWF  04
006D:  BCF    03.7
006E:  BSF    03.5
006F:  MOVF   50,W
0070:  XORWF  54,W
0071:  ANDLW  80
0072:  MOVWF  5A
0073:  BTFSS  50.7
0074:  GOTO   080
0075:  COMF   4D,F
0076:  COMF   4E,F
0077:  COMF   4F,F
0078:  COMF   50,F
0079:  INCF   4D,F
007A:  BTFSC  03.2
007B:  INCF   4E,F
007C:  BTFSC  03.2
007D:  INCF   4F,F
007E:  BTFSC  03.2
007F:  INCF   50,F
0080:  BTFSS  54.7
0081:  GOTO   08D
0082:  COMF   51,F
0083:  COMF   52,F
0084:  COMF   53,F
0085:  COMF   54,F
0086:  INCF   51,F
0087:  BTFSC  03.2
0088:  INCF   52,F
0089:  BTFSC  03.2
008A:  INCF   53,F
008B:  BTFSC  03.2
008C:  INCF   54,F
008D:  CLRF   77
008E:  CLRF   78
008F:  CLRF   79
0090:  CLRF   7A
0091:  CLRF   55
0092:  CLRF   56
0093:  CLRF   57
0094:  CLRF   58
0095:  MOVF   54,W
0096:  IORWF  53,W
0097:  IORWF  52,W
0098:  IORWF  51,W
0099:  BTFSC  03.2
009A:  GOTO   0CB
009B:  MOVLW  20
009C:  MOVWF  59
009D:  BCF    03.0
009E:  RLF    4D,F
009F:  RLF    4E,F
00A0:  RLF    4F,F
00A1:  RLF    50,F
00A2:  RLF    55,F
00A3:  RLF    56,F
00A4:  RLF    57,F
00A5:  RLF    58,F
00A6:  MOVF   54,W
00A7:  SUBWF  58,W
00A8:  BTFSS  03.2
00A9:  GOTO   0B4
00AA:  MOVF   53,W
00AB:  SUBWF  57,W
00AC:  BTFSS  03.2
00AD:  GOTO   0B4
00AE:  MOVF   52,W
00AF:  SUBWF  56,W
00B0:  BTFSS  03.2
00B1:  GOTO   0B4
00B2:  MOVF   51,W
00B3:  SUBWF  55,W
00B4:  BTFSS  03.0
00B5:  GOTO   0C5
00B6:  MOVF   51,W
00B7:  SUBWF  55,F
00B8:  MOVF   52,W
00B9:  BTFSS  03.0
00BA:  INCFSZ 52,W
00BB:  SUBWF  56,F
00BC:  MOVF   53,W
00BD:  BTFSS  03.0
00BE:  INCFSZ 53,W
00BF:  SUBWF  57,F
00C0:  MOVF   54,W
00C1:  BTFSS  03.0
00C2:  INCFSZ 54,W
00C3:  SUBWF  58,F
00C4:  BSF    03.0
00C5:  RLF    77,F
00C6:  RLF    78,F
00C7:  RLF    79,F
00C8:  RLF    7A,F
00C9:  DECFSZ 59,F
00CA:  GOTO   09D
00CB:  BTFSS  5A.7
00CC:  GOTO   0D8
00CD:  COMF   77,F
00CE:  COMF   78,F
00CF:  COMF   79,F
00D0:  COMF   7A,F
00D1:  INCF   77,F
00D2:  BTFSC  03.2
00D3:  INCF   78,F
00D4:  BTFSC  03.2
00D5:  INCF   79,F
00D6:  BTFSC  03.2
00D7:  INCF   7A,F
00D8:  MOVF   55,W
00D9:  MOVWF  00
00DA:  INCF   04,F
00DB:  MOVF   56,W
00DC:  MOVWF  00
00DD:  INCF   04,F
00DE:  MOVF   57,W
00DF:  MOVWF  00
00E0:  INCF   04,F
00E1:  MOVF   58,W
00E2:  MOVWF  00
00E3:  BCF    03.5
00E4:  RETURN
*
014D:  BSF    03.5
014E:  MOVF   3A,W
014F:  BTFSC  03.2
0150:  GOTO   1BE
0151:  MOVWF  42
0152:  MOVF   3E,W
0153:  BTFSC  03.2
0154:  GOTO   1BE
0155:  ADDWF  42,F
0156:  BTFSC  03.0
0157:  GOTO   15F
0158:  MOVLW  7F
0159:  SUBWF  42,F
015A:  BTFSS  03.0
015B:  GOTO   1BE
015C:  BTFSC  03.2
015D:  GOTO   1BE
015E:  GOTO   163
015F:  MOVLW  81
0160:  ADDWF  42,F
0161:  BTFSC  03.0
0162:  GOTO   1BE
0163:  MOVF   42,W
0164:  MOVWF  77
0165:  CLRF   78
0166:  CLRF   79
0167:  CLRF   7A
0168:  MOVF   3B,W
0169:  MOVWF  46
016A:  BSF    46.7
016B:  MOVF   3C,W
016C:  MOVWF  45
016D:  MOVF   3D,W
016E:  MOVWF  44
016F:  MOVLW  18
0170:  MOVWF  42
0171:  CLRF   43
0172:  BTFSS  44.0
0173:  GOTO   18C
0174:  MOVF   41,W
0175:  ADDWF  7A,F
0176:  BTFSS  03.0
0177:  GOTO   17E
0178:  INCF   79,F
0179:  BTFSS  03.2
017A:  GOTO   17E
017B:  INCF   78,F
017C:  BTFSC  03.2
017D:  BSF    43.7
017E:  MOVF   40,W
017F:  ADDWF  79,F
0180:  BTFSS  03.0
0181:  GOTO   185
0182:  INCF   78,F
0183:  BTFSC  03.2
0184:  BSF    43.7
0185:  MOVF   3F,W
0186:  MOVWF  3C
0187:  BSF    3C.7
0188:  MOVF   3C,W
0189:  ADDWF  78,F
018A:  BTFSC  03.0
018B:  BSF    43.7
018C:  RLF    43,F
018D:  RRF    78,F
018E:  RRF    79,F
018F:  RRF    7A,F
0190:  RRF    46,F
0191:  RRF    45,F
0192:  RRF    44,F
0193:  BCF    03.0
0194:  DECFSZ 42,F
0195:  GOTO   171
0196:  MOVLW  01
0197:  ADDWF  77,F
0198:  BTFSC  03.0
0199:  GOTO   1BE
019A:  BTFSC  78.7
019B:  GOTO   1A3
019C:  RLF    46,F
019D:  RLF    7A,F
019E:  RLF    79,F
019F:  RLF    78,F
01A0:  DECF   77,F
01A1:  BTFSC  03.2
01A2:  GOTO   1BE
01A3:  BTFSS  46.7
01A4:  GOTO   1B4
01A5:  INCF   7A,F
01A6:  BTFSS  03.2
01A7:  GOTO   1B4
01A8:  INCF   79,F
01A9:  BTFSS  03.2
01AA:  GOTO   1B4
01AB:  INCF   78,F
01AC:  BTFSS  03.2
01AD:  GOTO   1B4
01AE:  RRF    78,F
01AF:  RRF    79,F
01B0:  RRF    7A,F
01B1:  INCF   77,F
01B2:  BTFSC  03.2
01B3:  GOTO   1BE
01B4:  MOVF   3B,W
01B5:  MOVWF  43
01B6:  MOVF   3F,W
01B7:  XORWF  43,F
01B8:  BTFSS  43.7
01B9:  GOTO   1BC
01BA:  BSF    78.7
01BB:  GOTO   1C2
01BC:  BCF    78.7
01BD:  GOTO   1C2
01BE:  CLRF   77
01BF:  CLRF   78
01C0:  CLRF   79
01C1:  CLRF   7A
01C2:  BCF    03.5
01C3:  RETURN
01C4:  MOVLW  80
01C5:  BTFSS  03.1
01C6:  GOTO   1CA
01C7:  BSF    03.5
01C8:  XORWF  3F,F
01C9:  BCF    03.5
01CA:  BSF    03.5
01CB:  CLRF   44
01CC:  CLRF   45
01CD:  MOVF   3B,W
01CE:  MOVWF  43
01CF:  MOVF   3F,W
01D0:  XORWF  43,F
01D1:  MOVF   3A,W
01D2:  BTFSC  03.2
01D3:  GOTO   2B8
01D4:  MOVWF  42
01D5:  MOVWF  77
01D6:  MOVF   3E,W
01D7:  BTFSC  03.2
01D8:  GOTO   2C1
01D9:  SUBWF  42,F
01DA:  BTFSC  03.2
01DB:  GOTO   25D
01DC:  BTFSS  03.0
01DD:  GOTO   21B
01DE:  MOVF   3F,W
01DF:  MOVWF  48
01E0:  BSF    48.7
01E1:  MOVF   40,W
01E2:  MOVWF  47
01E3:  MOVF   41,W
01E4:  MOVWF  46
01E5:  CLRF   45
01E6:  BCF    03.0
01E7:  RRF    48,F
01E8:  RRF    47,F
01E9:  RRF    46,F
01EA:  RRF    45,F
01EB:  DECFSZ 42,F
01EC:  GOTO   1E5
01ED:  BTFSS  43.7
01EE:  GOTO   1F2
01EF:  BSF    44.0
01F0:  GOTO   2D5
01F1:  BCF    44.0
01F2:  BCF    42.0
01F3:  BSF    44.4
01F4:  MOVLW  BD
01F5:  MOVWF  04
01F6:  BCF    03.7
01F7:  GOTO   2EA
01F8:  BCF    44.4
01F9:  BTFSC  43.7
01FA:  GOTO   205
01FB:  BTFSS  42.0
01FC:  GOTO   210
01FD:  RRF    48,F
01FE:  RRF    47,F
01FF:  RRF    46,F
0200:  RRF    45,F
0201:  INCF   77,F
0202:  BTFSC  03.2
0203:  GOTO   2D0
0204:  GOTO   210
0205:  BTFSC  48.7
0206:  GOTO   213
0207:  BCF    03.0
0208:  RLF    45,F
0209:  RLF    46,F
020A:  RLF    47,F
020B:  RLF    48,F
020C:  DECF   77,F
020D:  BTFSC  03.2
020E:  GOTO   2D0
020F:  GOTO   205
0210:  BSF    44.6
0211:  GOTO   27D
0212:  BCF    44.6
0213:  MOVF   3B,W
0214:  MOVWF  43
0215:  BTFSS  43.7
0216:  GOTO   219
0217:  BSF    48.7
0218:  GOTO   2C9
0219:  BCF    48.7
021A:  GOTO   2C9
021B:  MOVF   3E,W
021C:  MOVWF  42
021D:  MOVWF  77
021E:  MOVF   3A,W
021F:  SUBWF  42,F
0220:  MOVF   3B,W
0221:  MOVWF  48
0222:  BSF    48.7
0223:  MOVF   3C,W
0224:  MOVWF  47
0225:  MOVF   3D,W
0226:  MOVWF  46
0227:  CLRF   45
0228:  BCF    03.0
0229:  RRF    48,F
022A:  RRF    47,F
022B:  RRF    46,F
022C:  RRF    45,F
022D:  DECFSZ 42,F
022E:  GOTO   227
022F:  BTFSS  43.7
0230:  GOTO   234
0231:  BSF    44.1
0232:  GOTO   2D5
0233:  BCF    44.1
0234:  BCF    42.0
0235:  BSF    44.5
0236:  MOVLW  C1
0237:  MOVWF  04
0238:  BCF    03.7
0239:  GOTO   2EA
023A:  BCF    44.5
023B:  BTFSC  43.7
023C:  GOTO   247
023D:  BTFSS  42.0
023E:  GOTO   252
023F:  RRF    48,F
0240:  RRF    47,F
0241:  RRF    46,F
0242:  RRF    45,F
0243:  INCF   77,F
0244:  BTFSC  03.2
0245:  GOTO   2D0
0246:  GOTO   252
0247:  BTFSC  48.7
0248:  GOTO   255
0249:  BCF    03.0
024A:  RLF    45,F
024B:  RLF    46,F
024C:  RLF    47,F
024D:  RLF    48,F
024E:  DECF   77,F
024F:  BTFSC  03.2
0250:  GOTO   2D0
0251:  GOTO   247
0252:  BSF    44.7
0253:  GOTO   27D
0254:  BCF    44.7
0255:  MOVF   3F,W
0256:  MOVWF  43
0257:  BTFSS  43.7
0258:  GOTO   25B
0259:  BSF    48.7
025A:  GOTO   2C9
025B:  BCF    48.7
025C:  GOTO   2C9
025D:  MOVF   3F,W
025E:  MOVWF  48
025F:  BSF    48.7
0260:  MOVF   40,W
0261:  MOVWF  47
0262:  MOVF   41,W
0263:  MOVWF  46
0264:  BTFSS  43.7
0265:  GOTO   26A
0266:  BCF    48.7
0267:  BSF    44.2
0268:  GOTO   2D5
0269:  BCF    44.2
026A:  CLRF   45
026B:  BCF    42.0
026C:  MOVLW  BD
026D:  MOVWF  04
026E:  BCF    03.7
026F:  GOTO   2EA
0270:  BTFSC  43.7
0271:  GOTO   293
0272:  MOVF   3B,W
0273:  MOVWF  43
0274:  BTFSS  42.0
0275:  GOTO   27D
0276:  RRF    48,F
0277:  RRF    47,F
0278:  RRF    46,F
0279:  RRF    45,F
027A:  INCF   77,F
027B:  BTFSC  03.2
027C:  GOTO   2D0
027D:  BTFSS  45.7
027E:  GOTO   28E
027F:  INCF   46,F
0280:  BTFSS  03.2
0281:  GOTO   28E
0282:  INCF   47,F
0283:  BTFSS  03.2
0284:  GOTO   28E
0285:  INCF   48,F
0286:  BTFSS  03.2
0287:  GOTO   28E
0288:  RRF    48,F
0289:  RRF    47,F
028A:  RRF    46,F
028B:  INCF   77,F
028C:  BTFSC  03.2
028D:  GOTO   2D0
028E:  BTFSC  44.6
028F:  GOTO   212
0290:  BTFSC  44.7
0291:  GOTO   254
0292:  GOTO   2B2
0293:  MOVLW  80
0294:  XORWF  48,F
0295:  BTFSS  48.7
0296:  GOTO   29B
0297:  GOTO   2D5
0298:  MOVF   3F,W
0299:  MOVWF  43
029A:  GOTO   2A8
029B:  MOVF   3B,W
029C:  MOVWF  43
029D:  MOVF   48,F
029E:  BTFSS  03.2
029F:  GOTO   2A8
02A0:  MOVF   47,F
02A1:  BTFSS  03.2
02A2:  GOTO   2A8
02A3:  MOVF   46,F
02A4:  BTFSS  03.2
02A5:  GOTO   2A8
02A6:  CLRF   77
02A7:  GOTO   2C9
02A8:  BTFSC  48.7
02A9:  GOTO   2B2
02AA:  BCF    03.0
02AB:  RLF    45,F
02AC:  RLF    46,F
02AD:  RLF    47,F
02AE:  RLF    48,F
02AF:  DECFSZ 77,F
02B0:  GOTO   2A8
02B1:  GOTO   2D0
02B2:  BTFSS  43.7
02B3:  GOTO   2B6
02B4:  BSF    48.7
02B5:  GOTO   2C9
02B6:  BCF    48.7
02B7:  GOTO   2C9
02B8:  MOVF   3E,W
02B9:  MOVWF  77
02BA:  MOVF   3F,W
02BB:  MOVWF  48
02BC:  MOVF   40,W
02BD:  MOVWF  47
02BE:  MOVF   41,W
02BF:  MOVWF  46
02C0:  GOTO   2C9
02C1:  MOVF   3A,W
02C2:  MOVWF  77
02C3:  MOVF   3B,W
02C4:  MOVWF  48
02C5:  MOVF   3C,W
02C6:  MOVWF  47
02C7:  MOVF   3D,W
02C8:  MOVWF  46
02C9:  MOVF   48,W
02CA:  MOVWF  78
02CB:  MOVF   47,W
02CC:  MOVWF  79
02CD:  MOVF   46,W
02CE:  MOVWF  7A
02CF:  GOTO   308
02D0:  CLRF   77
02D1:  CLRF   78
02D2:  CLRF   79
02D3:  CLRF   7A
02D4:  GOTO   308
02D5:  CLRF   45
02D6:  COMF   46,F
02D7:  COMF   47,F
02D8:  COMF   48,F
02D9:  COMF   45,F
02DA:  INCF   45,F
02DB:  BTFSS  03.2
02DC:  GOTO   2E3
02DD:  INCF   46,F
02DE:  BTFSS  03.2
02DF:  GOTO   2E3
02E0:  INCF   47,F
02E1:  BTFSC  03.2
02E2:  INCF   48,F
02E3:  BTFSC  44.0
02E4:  GOTO   1F1
02E5:  BTFSC  44.1
02E6:  GOTO   233
02E7:  BTFSC  44.2
02E8:  GOTO   269
02E9:  GOTO   298
02EA:  MOVF   00,W
02EB:  ADDWF  46,F
02EC:  BTFSS  03.0
02ED:  GOTO   2F4
02EE:  INCF   47,F
02EF:  BTFSS  03.2
02F0:  GOTO   2F4
02F1:  INCF   48,F
02F2:  BTFSC  03.2
02F3:  BSF    42.0
02F4:  DECF   04,F
02F5:  MOVF   00,W
02F6:  ADDWF  47,F
02F7:  BTFSS  03.0
02F8:  GOTO   2FC
02F9:  INCF   48,F
02FA:  BTFSC  03.2
02FB:  BSF    42.0
02FC:  DECF   04,F
02FD:  MOVF   00,W
02FE:  BTFSS  00.7
02FF:  XORLW  80
0300:  ADDWF  48,F
0301:  BTFSC  03.0
0302:  BSF    42.0
0303:  BTFSC  44.4
0304:  GOTO   1F8
0305:  BTFSC  44.5
0306:  GOTO   23A
0307:  GOTO   270
0308:  BCF    03.5
0309:  RETURN
030A:  BSF    03.5
030B:  MOVF   37,W
030C:  MOVWF  3E
030D:  MOVF   3B,W
030E:  XORWF  3E,F
030F:  BTFSS  3E.7
0310:  GOTO   316
0311:  BCF    03.2
0312:  BCF    03.0
0313:  BTFSC  37.7
0314:  BSF    03.0
0315:  GOTO   349
0316:  MOVF   37,W
0317:  MOVWF  3E
0318:  MOVF   3A,W
0319:  MOVWF  3F
031A:  MOVF   36,W
031B:  SUBWF  3F,F
031C:  BTFSC  03.2
031D:  GOTO   324
031E:  BTFSS  3E.7
031F:  GOTO   349
0320:  MOVF   03,W
0321:  XORLW  01
0322:  MOVWF  03
0323:  GOTO   349
0324:  MOVF   3B,W
0325:  MOVWF  3F
0326:  MOVF   37,W
0327:  SUBWF  3F,F
0328:  BTFSC  03.2
0329:  GOTO   330
032A:  BTFSS  3E.7
032B:  GOTO   349
032C:  MOVF   03,W
032D:  XORLW  01
032E:  MOVWF  03
032F:  GOTO   349
0330:  MOVF   3C,W
0331:  MOVWF  3F
0332:  MOVF   38,W
0333:  SUBWF  3F,F
0334:  BTFSC  03.2
0335:  GOTO   33C
0336:  BTFSS  3E.7
0337:  GOTO   349
0338:  MOVF   03,W
0339:  XORLW  01
033A:  MOVWF  03
033B:  GOTO   349
033C:  MOVF   3D,W
033D:  MOVWF  3F
033E:  MOVF   39,W
033F:  SUBWF  3F,F
0340:  BTFSC  03.2
0341:  GOTO   348
0342:  BTFSS  3E.7
0343:  GOTO   349
0344:  MOVF   03,W
0345:  XORLW  01
0346:  MOVWF  03
0347:  GOTO   349
0348:  BCF    03.0
0349:  BCF    03.5
034A:  RETURN
*
037B:  MOVLW  20
037C:  MOVWF  51
037D:  CLRF   4D
037E:  CLRF   4E
037F:  CLRF   4F
0380:  CLRF   50
0381:  MOVF   48,W
0382:  MOVWF  7A
0383:  MOVF   47,W
0384:  MOVWF  79
0385:  MOVF   46,W
0386:  MOVWF  78
0387:  MOVF   45,W
0388:  MOVWF  77
0389:  BCF    03.0
038A:  BTFSS  77.0
038B:  GOTO   39A
038C:  MOVF   49,W
038D:  ADDWF  4D,F
038E:  MOVF   4A,W
038F:  BTFSC  03.0
0390:  INCFSZ 4A,W
0391:  ADDWF  4E,F
0392:  MOVF   4B,W
0393:  BTFSC  03.0
0394:  INCFSZ 4B,W
0395:  ADDWF  4F,F
0396:  MOVF   4C,W
0397:  BTFSC  03.0
0398:  INCFSZ 4C,W
0399:  ADDWF  50,F
039A:  RRF    50,F
039B:  RRF    4F,F
039C:  RRF    4E,F
039D:  RRF    4D,F
039E:  RRF    7A,F
039F:  RRF    79,F
03A0:  RRF    78,F
03A1:  RRF    77,F
03A2:  DECFSZ 51,F
03A3:  GOTO   389
*
0486:  MOVF   00,F
0487:  BTFSC  03.2
0488:  GOTO   4A9
0489:  CLRF   37
048A:  MOVF   04,W
048B:  MOVWF  36
048C:  BCF    37.0
048D:  BTFSC  03.7
048E:  BSF    37.0
048F:  MOVF   00,W
0490:  MOVWF  38
0491:  MOVF   70,W
0492:  MOVWF  04
0493:  BCF    03.7
0494:  BTFSC  71.0
0495:  BSF    03.7
0496:  MOVF   38,W
0497:  MOVWF  00
0498:  INCF   04,F
0499:  CLRF   00
049A:  INCF   70,F
049B:  BTFSC  03.2
049C:  INCF   71,F
049D:  MOVF   36,W
049E:  MOVWF  04
049F:  BCF    03.7
04A0:  BTFSC  37.0
04A1:  BSF    03.7
04A2:  INCF   04,F
04A3:  BTFSS  03.2
04A4:  GOTO   4A8
04A5:  BCF    03.5
04A6:  INCF   05,F
04A7:  BSF    03.5
04A8:  GOTO   486
*
04F9:  MOVLW  8E
04FA:  MOVWF  77
04FB:  MOVF   37,W
04FC:  MOVWF  78
04FD:  MOVF   36,W
04FE:  MOVWF  79
04FF:  CLRF   7A
0500:  MOVF   78,F
0501:  BTFSS  03.2
0502:  GOTO   50D
0503:  MOVF   79,W
0504:  MOVWF  78
0505:  CLRF   79
0506:  MOVLW  08
0507:  SUBWF  77,F
0508:  MOVF   78,F
0509:  BTFSS  03.2
050A:  GOTO   50D
050B:  CLRF   77
050C:  GOTO   515
050D:  BCF    03.0
050E:  BTFSC  78.7
050F:  GOTO   514
0510:  RLF    79,F
0511:  RLF    78,F
0512:  DECF   77,F
0513:  GOTO   50D
0514:  BCF    78.7
*
0654:  MOVLW  8E
0655:  MOVWF  77
0656:  MOVF   36,W
0657:  SUBWF  77,F
0658:  MOVF   37,W
0659:  MOVWF  79
065A:  MOVF   38,W
065B:  MOVWF  78
065C:  BSF    79.7
065D:  MOVF   77,F
065E:  BTFSC  03.2
065F:  GOTO   66B
0660:  BCF    03.0
0661:  MOVF   79,F
0662:  BTFSS  03.2
0663:  GOTO   667
0664:  MOVF   78,F
0665:  BTFSC  03.2
0666:  GOTO   66B
0667:  RRF    79,F
0668:  RRF    78,F
0669:  DECFSZ 77,F
066A:  GOTO   660
066B:  BTFSS  37.7
066C:  GOTO   672
066D:  COMF   78,F
066E:  COMF   79,F
066F:  INCF   78,F
0670:  BTFSC  03.2
0671:  INCF   79,F
*
06FD:  BSF    03.5
06FE:  MOVF   28,W
06FF:  BTFSC  03.2
0700:  GOTO   7C3
0701:  MOVWF  34
0702:  MOVF   2C,W
0703:  BTFSC  03.2
0704:  GOTO   7C3
0705:  SUBWF  34,F
0706:  BTFSS  03.0
0707:  GOTO   70D
0708:  MOVLW  7F
0709:  ADDWF  34,F
070A:  BTFSC  03.0
070B:  GOTO   7C3
070C:  GOTO   713
070D:  MOVLW  81
070E:  SUBWF  34,F
070F:  BTFSS  03.0
0710:  GOTO   7C3
0711:  BTFSC  03.2
0712:  GOTO   7C3
0713:  MOVF   34,W
0714:  MOVWF  77
0715:  CLRF   78
0716:  CLRF   79
0717:  CLRF   7A
0718:  CLRF   33
0719:  MOVF   29,W
071A:  MOVWF  32
071B:  BSF    32.7
071C:  MOVF   2A,W
071D:  MOVWF  31
071E:  MOVF   2B,W
071F:  MOVWF  30
0720:  MOVLW  19
0721:  MOVWF  34
0722:  MOVF   2F,W
0723:  SUBWF  30,F
0724:  BTFSC  03.0
0725:  GOTO   736
0726:  MOVLW  01
0727:  SUBWF  31,F
0728:  BTFSC  03.0
0729:  GOTO   736
072A:  SUBWF  32,F
072B:  BTFSC  03.0
072C:  GOTO   736
072D:  SUBWF  33,F
072E:  BTFSC  03.0
072F:  GOTO   736
0730:  INCF   33,F
0731:  INCF   32,F
0732:  INCF   31,F
0733:  MOVF   2F,W
0734:  ADDWF  30,F
0735:  GOTO   768
0736:  MOVF   2E,W
0737:  SUBWF  31,F
0738:  BTFSC  03.0
0739:  GOTO   751
073A:  MOVLW  01
073B:  SUBWF  32,F
073C:  BTFSC  03.0
073D:  GOTO   751
073E:  SUBWF  33,F
073F:  BTFSC  03.0
0740:  GOTO   751
0741:  INCF   33,F
0742:  INCF   32,F
0743:  MOVF   2E,W
0744:  ADDWF  31,F
0745:  MOVF   2F,W
0746:  ADDWF  30,F
0747:  BTFSS  03.0
0748:  GOTO   768
0749:  INCF   31,F
074A:  BTFSS  03.2
074B:  GOTO   768
074C:  INCF   32,F
074D:  BTFSS  03.2
074E:  GOTO   768
074F:  INCF   33,F
0750:  GOTO   768
0751:  MOVF   2D,W
0752:  IORLW  80
0753:  SUBWF  32,F
0754:  BTFSC  03.0
0755:  GOTO   767
0756:  MOVLW  01
0757:  SUBWF  33,F
0758:  BTFSC  03.0
0759:  GOTO   767
075A:  INCF   33,F
075B:  MOVF   2D,W
075C:  IORLW  80
075D:  ADDWF  32,F
075E:  MOVF   2E,W
075F:  ADDWF  31,F
0760:  BTFSS  03.0
0761:  GOTO   745
0762:  INCF   32,F
0763:  BTFSS  03.2
0764:  GOTO   745
0765:  INCF   33,F
0766:  GOTO   745
0767:  BSF    7A.0
0768:  DECFSZ 34,F
0769:  GOTO   76B
076A:  GOTO   776
076B:  BCF    03.0
076C:  RLF    30,F
076D:  RLF    31,F
076E:  RLF    32,F
076F:  RLF    33,F
0770:  BCF    03.0
0771:  RLF    7A,F
0772:  RLF    79,F
0773:  RLF    78,F
0774:  RLF    35,F
0775:  GOTO   722
0776:  BTFSS  35.0
0777:  GOTO   77E
0778:  BCF    03.0
0779:  RRF    78,F
077A:  RRF    79,F
077B:  RRF    7A,F
077C:  RRF    35,F
077D:  GOTO   781
077E:  DECF   77,F
077F:  BTFSC  03.2
0780:  GOTO   7C3
0781:  BTFSC  35.7
0782:  GOTO   7AA
0783:  BCF    03.0
0784:  RLF    30,F
0785:  RLF    31,F
0786:  RLF    32,F
0787:  RLF    33,F
0788:  MOVF   2F,W
0789:  SUBWF  30,F
078A:  BTFSC  03.0
078B:  GOTO   796
078C:  MOVLW  01
078D:  SUBWF  31,F
078E:  BTFSC  03.0
078F:  GOTO   796
0790:  SUBWF  32,F
0791:  BTFSC  03.0
0792:  GOTO   796
0793:  SUBWF  33,F
0794:  BTFSS  03.0
0795:  GOTO   7B9
0796:  MOVF   2E,W
0797:  SUBWF  31,F
0798:  BTFSC  03.0
0799:  GOTO   7A1
079A:  MOVLW  01
079B:  SUBWF  32,F
079C:  BTFSC  03.0
079D:  GOTO   7A1
079E:  SUBWF  33,F
079F:  BTFSS  03.0
07A0:  GOTO   7B9
07A1:  MOVF   2D,W
07A2:  IORLW  80
07A3:  SUBWF  32,F
07A4:  BTFSC  03.0
07A5:  GOTO   7AA
07A6:  MOVLW  01
07A7:  SUBWF  33,F
07A8:  BTFSS  03.0
07A9:  GOTO   7B9
07AA:  INCF   7A,F
07AB:  BTFSS  03.2
07AC:  GOTO   7B9
07AD:  INCF   79,F
07AE:  BTFSS  03.2
07AF:  GOTO   7B9
07B0:  INCF   78,F
07B1:  BTFSS  03.2
07B2:  GOTO   7B9
07B3:  INCF   77,F
07B4:  BTFSC  03.2
07B5:  GOTO   7C3
07B6:  RRF    78,F
07B7:  RRF    79,F
07B8:  RRF    7A,F
07B9:  MOVF   29,W
07BA:  MOVWF  34
07BB:  MOVF   2D,W
07BC:  XORWF  34,F
07BD:  BTFSS  34.7
07BE:  GOTO   7C1
07BF:  BSF    78.7
07C0:  GOTO   7C7
07C1:  BCF    78.7
07C2:  GOTO   7C7
07C3:  CLRF   77
07C4:  CLRF   78
07C5:  CLRF   79
07C6:  CLRF   7A
07C7:  BCF    03.5
07C8:  RETURN
....................  
.................... #list 
....................  
.................... #FUSES NOWDT, HS, NOPUT,NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT 
.................... #use delay(clock=8000000) 
*
00E5:  MOVLW  B9
00E6:  MOVWF  04
00E7:  BCF    03.7
00E8:  MOVF   00,W
00E9:  BTFSC  03.2
00EA:  GOTO   0F8
00EB:  MOVLW  02
00EC:  MOVWF  78
00ED:  CLRF   77
00EE:  DECFSZ 77,F
00EF:  GOTO   0EE
00F0:  DECFSZ 78,F
00F1:  GOTO   0ED
00F2:  MOVLW  97
00F3:  MOVWF  77
00F4:  DECFSZ 77,F
00F5:  GOTO   0F4
00F6:  DECFSZ 00,F
00F7:  GOTO   0EB
00F8:  RETURN
.................... #use rs232 (baud=9600 , parity=n , xmit=pin_C6 , rcv=pin_C7 )  
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0832:  BCF    03.6
0833:  CLRF   28
0834:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
0363:  CLRF   40
0364:  CLRF   3F
0365:  CLRF   3E
0366:  MOVLW  01
0367:  MOVWF  3D
0368:  CLRF   42
0369:  CLRF   43
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
036A:  BTFSS  39.7
036B:  GOTO   3AC
....................          sign=1;        // Check for negative number 
036C:  MOVLW  01
036D:  MOVWF  42
....................          num*=-1; 
036E:  MOVF   39,W
036F:  MOVWF  48
0370:  MOVF   38,W
0371:  MOVWF  47
0372:  MOVF   37,W
0373:  MOVWF  46
0374:  MOVF   36,W
0375:  MOVWF  45
0376:  MOVLW  FF
0377:  MOVWF  4C
0378:  MOVWF  4B
0379:  MOVWF  4A
037A:  MOVWF  49
*
03A4:  MOVF   7A,W
03A5:  MOVWF  39
03A6:  MOVF   79,W
03A7:  MOVWF  38
03A8:  MOVF   78,W
03A9:  MOVWF  37
03AA:  MOVF   77,W
03AB:  MOVWF  36
....................      } 
....................  
....................      while(temp>0) { 
03AC:  MOVF   3D,F
03AD:  BTFSS  03.2
03AE:  GOTO   3B8
03AF:  MOVF   3E,F
03B0:  BTFSS  03.2
03B1:  GOTO   3B8
03B2:  MOVF   3F,F
03B3:  BTFSS  03.2
03B4:  GOTO   3B8
03B5:  MOVF   40,F
03B6:  BTFSC  03.2
03B7:  GOTO   434
....................          temp=(num/base); 
03B8:  BCF    03.1
03B9:  MOVF   39,W
03BA:  MOVWF  50
03BB:  MOVF   38,W
03BC:  MOVWF  4F
03BD:  MOVF   37,W
03BE:  MOVWF  4E
03BF:  MOVF   36,W
03C0:  MOVWF  4D
03C1:  CLRF   54
03C2:  CLRF   53
03C3:  CLRF   52
03C4:  MOVF   3A,W
03C5:  MOVWF  51
03C6:  BCF    03.5
03C7:  CALL   069
03C8:  MOVF   7A,W
03C9:  BSF    03.5
03CA:  MOVWF  40
03CB:  MOVF   79,W
03CC:  MOVWF  3F
03CD:  MOVF   78,W
03CE:  MOVWF  3E
03CF:  MOVF   77,W
03D0:  MOVWF  3D
....................          s[cnt]=(num%base)+'0';    // Conversion 
03D1:  MOVF   43,W
03D2:  ADDWF  3B,W
03D3:  MOVWF  78
03D4:  MOVF   3C,W
03D5:  MOVWF  7A
03D6:  BTFSC  03.0
03D7:  INCF   7A,F
03D8:  MOVF   78,W
03D9:  MOVWF  45
03DA:  MOVF   7A,W
03DB:  MOVWF  46
03DC:  CLRF   48
03DD:  MOVF   04,W
03DE:  MOVWF  47
03DF:  BCF    48.0
03E0:  BTFSC  03.7
03E1:  BSF    48.0
03E2:  BSF    03.1
03E3:  MOVLW  C9
03E4:  MOVWF  04
03E5:  BCF    03.7
03E6:  MOVF   39,W
03E7:  MOVWF  50
03E8:  MOVF   38,W
03E9:  MOVWF  4F
03EA:  MOVF   37,W
03EB:  MOVWF  4E
03EC:  MOVF   36,W
03ED:  MOVWF  4D
03EE:  CLRF   54
03EF:  CLRF   53
03F0:  CLRF   52
03F1:  MOVF   3A,W
03F2:  MOVWF  51
03F3:  BCF    03.5
03F4:  CALL   069
03F5:  BSF    03.5
03F6:  MOVF   47,W
03F7:  MOVWF  04
03F8:  BCF    03.7
03F9:  BTFSC  48.0
03FA:  BSF    03.7
03FB:  MOVLW  30
03FC:  ADDWF  49,W
03FD:  MOVWF  77
03FE:  MOVF   4A,W
03FF:  MOVWF  78
0400:  MOVLW  00
0401:  BTFSC  03.0
0402:  MOVLW  01
0403:  ADDWF  78,F
0404:  MOVF   4B,W
0405:  MOVWF  79
0406:  MOVLW  00
0407:  BTFSC  03.0
0408:  MOVLW  01
0409:  ADDWF  79,F
040A:  MOVF   4C,W
040B:  MOVWF  7A
040C:  MOVLW  00
040D:  BTFSC  03.0
040E:  MOVLW  01
040F:  ADDWF  7A,F
0410:  MOVF   45,W
0411:  MOVWF  04
0412:  BCF    03.7
0413:  BTFSC  46.0
0414:  BSF    03.7
0415:  MOVF   77,W
0416:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
0417:  MOVF   43,W
0418:  ADDWF  3B,W
0419:  MOVWF  04
041A:  BCF    03.7
041B:  BTFSC  3C.0
041C:  BSF    03.7
041D:  MOVF   00,W
041E:  SUBLW  39
041F:  BTFSC  03.0
0420:  GOTO   42A
....................             s[cnt]+=0x7; 
0421:  MOVF   43,W
0422:  ADDWF  3B,W
0423:  MOVWF  04
0424:  BCF    03.7
0425:  BTFSC  3C.0
0426:  BSF    03.7
0427:  MOVLW  07
0428:  ADDWF  00,W
0429:  MOVWF  00
....................  
....................          cnt++; 
042A:  INCF   43,F
....................          num=temp; 
042B:  MOVF   40,W
042C:  MOVWF  39
042D:  MOVF   3F,W
042E:  MOVWF  38
042F:  MOVF   3E,W
0430:  MOVWF  37
0431:  MOVF   3D,W
0432:  MOVWF  36
0433:  GOTO   3AC
....................      } 
....................  
....................      if(sign==1) { 
0434:  DECFSZ 42,W
0435:  GOTO   43F
....................          s[cnt]=0x2D;      // Negative sign 
0436:  MOVF   43,W
0437:  ADDWF  3B,W
0438:  MOVWF  04
0439:  BCF    03.7
043A:  BTFSC  3C.0
043B:  BSF    03.7
043C:  MOVLW  2D
043D:  MOVWF  00
....................          cnt++; 
043E:  INCF   43,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
043F:  CLRF   41
0440:  BCF    03.0
0441:  RRF    43,W
0442:  SUBWF  41,W
0443:  BTFSC  03.0
0444:  GOTO   475
....................  
....................          c=s[i]; 
0445:  MOVF   41,W
0446:  ADDWF  3B,W
0447:  MOVWF  04
0448:  BCF    03.7
0449:  BTFSC  3C.0
044A:  BSF    03.7
044B:  MOVF   00,W
044C:  MOVWF  44
....................          s[i]=s[cnt-i-1];        // Reverse the number 
044D:  MOVF   41,W
044E:  ADDWF  3B,W
044F:  MOVWF  78
0450:  MOVF   3C,W
0451:  MOVWF  7A
0452:  BTFSC  03.0
0453:  INCF   7A,F
0454:  MOVF   78,W
0455:  MOVWF  45
0456:  MOVF   7A,W
0457:  MOVWF  46
0458:  MOVF   41,W
0459:  SUBWF  43,W
045A:  ADDLW  FF
045B:  ADDWF  3B,W
045C:  MOVWF  04
045D:  BCF    03.7
045E:  BTFSC  3C.0
045F:  BSF    03.7
0460:  MOVF   00,W
0461:  MOVWF  47
0462:  MOVF   45,W
0463:  MOVWF  04
0464:  BCF    03.7
0465:  BTFSC  46.0
0466:  BSF    03.7
0467:  MOVF   47,W
0468:  MOVWF  00
....................          s[cnt-i-1]=c; 
0469:  MOVF   41,W
046A:  SUBWF  43,W
046B:  ADDLW  FF
046C:  ADDWF  3B,W
046D:  MOVWF  04
046E:  BCF    03.7
046F:  BTFSC  3C.0
0470:  BSF    03.7
0471:  MOVF   44,W
0472:  MOVWF  00
0473:  INCF   41,F
0474:  GOTO   440
....................      } 
....................      s[cnt]='\0';     // End the string 
0475:  MOVF   43,W
0476:  ADDWF  3B,W
0477:  MOVWF  04
0478:  BCF    03.7
0479:  BTFSC  3C.0
047A:  BSF    03.7
047B:  CLRF   00
....................      return s; 
047C:  MOVF   3B,W
047D:  MOVWF  78
047E:  MOVF   3C,W
047F:  MOVWF  79
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //#include <main.h> 
.................... #use FAST_IO(E) 
.................... #use FAST_IO(D) 
.................... #define LCD_RS PIN_E0                         
.................... #define LCD_RW PIN_E1 
.................... #define LCD_EN PIN_E2 
.................... #define LCD_D4 PIN_D4                  
.................... #define LCD_D5 PIN_D5 
.................... #define LCD_D6 PIN_D6 
.................... #define LCD_D7 PIN_D7  
....................  
.................... #include "lcd.c" 
.................... /** 
....................   ****************************************************************************** 
....................   * Ten Tep      :        lcd_16x2.c 
....................   * Tac Gia      :        Nguyen Quy Nhat 
....................   * Cong Ty      :        MinhHaGroup 
....................   * Website      :        BanLinhKien.Vn 
....................   * Phien Ban    :        V1.0.0 
....................   * Ngay         :        31-07-2012 
....................   * Tom Tat      :        Dinh nghia cac ham dieu khien LCD 16x2. 
....................   *            
....................   * 
....................   ****************************************************************************** 
....................   * Chu Y        :   Phai dinh nghia cac chan su dung cho LCD vao ham main.h 
....................   *                       
....................   ****************************************************************************** 
....................   */ 
.................... //Tao Xung 
....................  void LCD_Enable(void) 
.................... { 
....................  output_high(LCD_EN); 
*
0130:  BSF    09.2
....................  delay_us(3); 
0131:  GOTO   132
0132:  GOTO   133
0133:  GOTO   134
....................  output_low(LCD_EN); 
0134:  BCF    09.2
....................  delay_us(50);  
0135:  MOVLW  20
0136:  MOVWF  77
0137:  DECFSZ 77,F
0138:  GOTO   137
0139:  GOTO   13A
013A:  NOP
013B:  RETURN
.................... } 
.................... //Ham Gui 4 Bit Du Lieu Ra LCD 
....................  void LCD_Send4Bit( unsigned char Data ) 
.................... { 
....................  output_bit(LCD_D4,Data&0x01); 
*
00F9:  BSF    03.5
00FA:  BTFSC  3C.0
00FB:  GOTO   100
00FC:  BCF    03.5
00FD:  BCF    08.4
00FE:  GOTO   102
00FF:  BSF    03.5
0100:  BCF    03.5
0101:  BSF    08.4
....................  output_bit(LCD_D5,(Data>>1)&1); 
0102:  BCF    03.0
0103:  BSF    03.5
0104:  RRF    3C,W
0105:  ANDLW  01
0106:  BTFSS  03.2
0107:  GOTO   10C
0108:  BCF    03.5
0109:  BCF    08.5
010A:  GOTO   10E
010B:  BSF    03.5
010C:  BCF    03.5
010D:  BSF    08.5
....................  output_bit(LCD_D6,(Data>>2)&1); 
010E:  BSF    03.5
010F:  RRF    3C,W
0110:  MOVWF  77
0111:  RRF    77,F
0112:  MOVLW  3F
0113:  ANDWF  77,F
0114:  MOVF   77,W
0115:  ANDLW  01
0116:  BTFSS  03.2
0117:  GOTO   11C
0118:  BCF    03.5
0119:  BCF    08.6
011A:  GOTO   11E
011B:  BSF    03.5
011C:  BCF    03.5
011D:  BSF    08.6
....................  output_bit(LCD_D7,(Data>>3)&1); 
011E:  BSF    03.5
011F:  RRF    3C,W
0120:  MOVWF  77
0121:  RRF    77,F
0122:  RRF    77,F
0123:  MOVLW  1F
0124:  ANDWF  77,F
0125:  MOVF   77,W
0126:  ANDLW  01
0127:  BTFSS  03.2
0128:  GOTO   12D
0129:  BCF    03.5
012A:  BCF    08.7
012B:  GOTO   12F
012C:  BSF    03.5
012D:  BCF    03.5
012E:  BSF    08.7
012F:  RETURN
.................... } 
.................... // Ham Gui 1 Lenh Cho LCD 
....................  void LCD_SendCommand (unsigned char command ) 
.................... { 
.................... LCD_Send4Bit  ( command >>4 );/* Gui 4 bit cao */ 
*
013C:  BSF    03.5
013D:  SWAPF  3A,W
013E:  MOVWF  3B
013F:  MOVLW  0F
0140:  ANDWF  3B,F
0141:  MOVF   3B,W
0142:  MOVWF  3C
0143:  BCF    03.5
0144:  CALL   0F9
.................... LCD_Enable () ; 
0145:  CALL   130
.................... LCD_Send4Bit  ( command  );      /* Gui 4 bit thap*/ 
0146:  BSF    03.5
0147:  MOVF   3A,W
0148:  MOVWF  3C
0149:  BCF    03.5
014A:  CALL   0F9
.................... LCD_Enable () ; 
014B:  CALL   130
014C:  RETURN
.................... } 
.................... // Ham Khoi Tao LCD 
....................  void LCD_Init ( void ) 
.................... { 
.................... output_drive(LCD_D4); 
*
0684:  BSF    03.5
0685:  BCF    08.4
.................... output_drive(LCD_D5); 
0686:  BCF    08.5
.................... output_drive(LCD_D6); 
0687:  BCF    08.6
.................... output_drive(LCD_D7); 
0688:  BCF    08.7
.................... output_drive(LCD_EN); 
0689:  BCF    09.2
.................... output_drive(LCD_RS); 
068A:  BCF    09.0
.................... output_drive(LCD_RW); 
068B:  BCF    09.1
068C:  BCF    03.5
068D:  CLRF   27
068E:  BTFSC  0B.7
068F:  BSF    27.7
0690:  BCF    0B.7
.................... LCD_Send4Bit(0x00); 
0691:  BSF    03.5
0692:  CLRF   3C
0693:  BCF    03.5
0694:  CALL   0F9
0695:  BTFSC  27.7
0696:  BSF    0B.7
0697:  CLRF   27
0698:  BTFSC  0B.7
0699:  BSF    27.7
069A:  BCF    0B.7
.................... delay_ms(20); 
069B:  MOVLW  14
069C:  BSF    03.5
069D:  MOVWF  39
069E:  BCF    03.5
069F:  CALL   0E5
06A0:  BTFSC  27.7
06A1:  BSF    0B.7
.................... output_low(LCD_RS); 
06A2:  BCF    09.0
.................... output_low(LCD_RW); 
06A3:  BCF    09.1
06A4:  CLRF   27
06A5:  BTFSC  0B.7
06A6:  BSF    27.7
06A7:  BCF    0B.7
.................... LCD_Send4Bit(0x03); 
06A8:  MOVLW  03
06A9:  BSF    03.5
06AA:  MOVWF  3C
06AB:  BCF    03.5
06AC:  CALL   0F9
06AD:  BTFSC  27.7
06AE:  BSF    0B.7
.................... LCD_Enable(); 
06AF:  CALL   130
06B0:  CLRF   27
06B1:  BTFSC  0B.7
06B2:  BSF    27.7
06B3:  BCF    0B.7
.................... delay_ms(5); 
06B4:  MOVLW  05
06B5:  BSF    03.5
06B6:  MOVWF  39
06B7:  BCF    03.5
06B8:  CALL   0E5
06B9:  BTFSC  27.7
06BA:  BSF    0B.7
.................... LCD_Enable(); 
06BB:  CALL   130
.................... delay_us(100); 
06BC:  MOVLW  42
06BD:  MOVWF  77
06BE:  DECFSZ 77,F
06BF:  GOTO   6BE
06C0:  NOP
.................... LCD_Enable(); 
06C1:  CALL   130
06C2:  CLRF   27
06C3:  BTFSC  0B.7
06C4:  BSF    27.7
06C5:  BCF    0B.7
.................... LCD_Send4Bit(0x02); 
06C6:  MOVLW  02
06C7:  BSF    03.5
06C8:  MOVWF  3C
06C9:  BCF    03.5
06CA:  CALL   0F9
06CB:  BTFSC  27.7
06CC:  BSF    0B.7
.................... LCD_Enable(); 
06CD:  CALL   130
06CE:  CLRF   27
06CF:  BTFSC  0B.7
06D0:  BSF    27.7
06D1:  BCF    0B.7
.................... LCD_SendCommand( 0x28 );      // giao thuc 4 bit, hien thi 2 hang, ki tu 5x8 
06D2:  MOVLW  28
06D3:  BSF    03.5
06D4:  MOVWF  3A
06D5:  BCF    03.5
06D6:  CALL   13C
06D7:  BTFSC  27.7
06D8:  BSF    0B.7
06D9:  CLRF   27
06DA:  BTFSC  0B.7
06DB:  BSF    27.7
06DC:  BCF    0B.7
.................... LCD_SendCommand( 0x0c);    // cho phep hien thi man hinh 
06DD:  MOVLW  0C
06DE:  BSF    03.5
06DF:  MOVWF  3A
06E0:  BCF    03.5
06E1:  CALL   13C
06E2:  BTFSC  27.7
06E3:  BSF    0B.7
06E4:  CLRF   27
06E5:  BTFSC  0B.7
06E6:  BSF    27.7
06E7:  BCF    0B.7
.................... LCD_SendCommand( 0x06 );      // tang ID, khong dich khung hinh 
06E8:  MOVLW  06
06E9:  BSF    03.5
06EA:  MOVWF  3A
06EB:  BCF    03.5
06EC:  CALL   13C
06ED:  BTFSC  27.7
06EE:  BSF    0B.7
06EF:  CLRF   27
06F0:  BTFSC  0B.7
06F1:  BSF    27.7
06F2:  BCF    0B.7
.................... LCD_SendCommand( 0x01 ); // xoa toan bo khung hinh 
06F3:  MOVLW  01
06F4:  BSF    03.5
06F5:  MOVWF  3A
06F6:  BCF    03.5
06F7:  CALL   13C
06F8:  BTFSC  27.7
06F9:  BSF    0B.7
06FA:  BSF    0A.3
06FB:  BCF    0A.4
06FC:  GOTO   037 (RETURN)
.................... } 
.................... void LCD_Gotoxy(unsigned char x, unsigned char y) 
.................... { 
....................   unsigned char address; 
....................   if(!y) 
*
04AC:  MOVF   37,F
04AD:  BTFSS  03.2
04AE:  GOTO   4B3
....................   address = (0x80+x); 
04AF:  MOVLW  80
04B0:  ADDWF  36,W
04B1:  MOVWF  38
04B2:  GOTO   4B6
....................   else 
....................   address = (0xC0+x); 
04B3:  MOVLW  C0
04B4:  ADDWF  36,W
04B5:  MOVWF  38
....................   delay_us(1000); 
04B6:  MOVLW  01
04B7:  MOVWF  39
04B8:  BCF    03.5
04B9:  CALL   0E5
....................   LCD_SendCommand(address); 
04BA:  BSF    03.5
04BB:  MOVF   38,W
04BC:  MOVWF  3A
04BD:  BCF    03.5
04BE:  CALL   13C
....................   delay_us(50); 
04BF:  MOVLW  20
04C0:  MOVWF  77
04C1:  DECFSZ 77,F
04C2:  GOTO   4C1
04C3:  GOTO   4C4
04C4:  NOP
.................... } 
.................... // Ham Xoa Man Hinh LCD 
.................... void LCD_Clear() 
.................... { 
....................   LCD_SendCommand(0x01);   
....................   delay_ms(10); 
.................... } 
.................... // Ham Gui 1 Ki Tu Len LCD 
....................  void LCD_PutChar ( unsigned char Data ) 
.................... { 
....................  output_high(LCD_RS); 
*
04DE:  BCF    03.5
04DF:  BSF    09.0
....................  LCD_SendCommand( Data ); 
04E0:  BSF    03.5
04E1:  MOVF   39,W
04E2:  MOVWF  3A
04E3:  BCF    03.5
04E4:  CALL   13C
....................  output_low(LCD_RS); 
04E5:  BCF    09.0
.................... } 
.................... void LCD_Puts (char *s) 
.................... { 
....................    while (*s) 
*
04C9:  MOVF   37,W
04CA:  MOVWF  7A
04CB:  MOVF   36,W
04CC:  MOVWF  04
04CD:  BCF    03.7
04CE:  BTFSC  7A.0
04CF:  BSF    03.7
04D0:  MOVF   00,F
04D1:  BTFSC  03.2
04D2:  GOTO   4EB
....................    { 
....................       LCD_PutChar(*s); 
04D3:  MOVF   37,W
04D4:  MOVWF  7A
04D5:  MOVF   36,W
04D6:  MOVWF  04
04D7:  BCF    03.7
04D8:  BTFSC  7A.0
04D9:  BSF    03.7
04DA:  MOVF   00,W
04DB:  MOVWF  38
04DC:  MOVF   38,W
04DD:  MOVWF  39
....................       s++; 
*
04E6:  BSF    03.5
04E7:  INCF   36,F
04E8:  BTFSC  03.2
04E9:  INCF   37,F
04EA:  GOTO   4C9
....................    } 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include <var.h> 
.................... #ifndef _VAR_ 
.................... #define _VAR_ 
....................    //const unsigned char  chu_so[10] = {0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90}; 
....................    //gia tri tren led 7 thanh          0  1     2    3     4    5   6     7   8    9 
....................    //const unsigned char OFF_LED=0xff; 
....................    //unsigned char buffer[3]; 
.................... #endif                                           
....................  
....................  
.................... int8 a=0; 
.................... int16 time=0,xung_thuc_te; 
.................... int8 tocdo=0; 
.................... float Kp,Ki,Kd,T,a0,a1,a2,e,e1=0,e2=0,u,u1=0; 
.................... int8 do_rong_xung; 
.................... char b[3], c[4]; 
.................... int8 str[4]; 
.................... // PHAN THIET LAP TOC DO QUAY CUA DONG CO 
....................  
.................... #INT_EXT 
.................... void ngat_EXT() 
.................... { 
....................  tocdo=65; 
*
003F:  MOVLW  41
0040:  MOVWF  33
....................  xung_thuc_te=tocdo/60;//Tinh Xung Thuc Te Chay Trong 10ms 
0041:  MOVF   33,W
0042:  BSF    03.5
0043:  MOVWF  36
0044:  MOVLW  3C
0045:  MOVWF  37
*
005A:  BCF    03.5
005B:  CLRF   32
005C:  MOVF   78,W
005D:  MOVWF  31
....................  set_pwm1_duty(125); 
005E:  MOVLW  7D
005F:  MOVWF  15
....................  disable_interrupts(INT_EXT); 
0060:  BCF    0B.4
....................  enable_interrupts(INT_CCP2); 
0061:  BSF    03.5
0062:  BSF    0D.0
....................  enable_interrupts(INT_RTCC); 
0063:  BCF    03.5
0064:  BSF    0B.5
.................... } 
....................  
0065:  BCF    0B.1
0066:  BCF    0A.3
0067:  BCF    0A.4
0068:  GOTO   025
.................... #INT_RTCC 
.................... void ngat_timer0() 
.................... { 
.................... time=time+1; 
*
034B:  MOVLW  01
034C:  ADDWF  2F,F
034D:  BTFSC  03.0
034E:  INCF   30,F
.................... //set_timer0(5); 
....................  
.................... if(time==5) 
034F:  MOVF   2F,W
0350:  SUBLW  05
0351:  BTFSS  03.2
0352:  GOTO   67A
0353:  MOVF   30,F
0354:  BTFSS  03.2
0355:  GOTO   67A
.................... { 
....................   
.................... itoa(a,10,c); 
0356:  BSF    03.5
0357:  CLRF   39
0358:  CLRF   38
0359:  CLRF   37
035A:  BCF    03.5
035B:  MOVF   2E,W
035C:  BSF    03.5
035D:  MOVWF  36
035E:  MOVLW  0A
035F:  MOVWF  3A
0360:  CLRF   3C
0361:  MOVLW  68
0362:  MOVWF  3B
.................... sprintf(str,c); 
*
0480:  CLRF   71
0481:  MOVLW  6C
0482:  MOVWF  70
0483:  MOVLW  68
0484:  MOVWF  04
0485:  BCF    03.7
.................... LCD_Gotoxy(1,0); 
*
04A9:  MOVLW  01
04AA:  MOVWF  36
04AB:  CLRF   37
.................... LCD_puts(str); 
*
04C5:  BSF    03.5
04C6:  CLRF   37
04C7:  MOVLW  6C
04C8:  MOVWF  36
.................... e=a-xung_thuc_te; 
*
04EB:  BCF    03.5
04EC:  MOVF   31,W
04ED:  SUBWF  2E,W
04EE:  MOVWF  77
04EF:  CLRF   7A
04F0:  MOVF   32,W
04F1:  BTFSS  03.0
04F2:  INCFSZ 32,W
04F3:  SUBWF  7A,F
04F4:  MOVF   77,W
04F5:  BSF    03.5
04F6:  MOVWF  36
04F7:  MOVF   7A,W
04F8:  MOVWF  37
*
0515:  MOVF   7A,W
0516:  BCF    03.5
0517:  MOVWF  53
0518:  MOVF   79,W
0519:  MOVWF  52
051A:  MOVF   78,W
051B:  MOVWF  51
051C:  MOVF   77,W
051D:  MOVWF  50
.................... u=u1+a0*e+a1*e1+a2*e2; 
051E:  MOVF   47,W
051F:  BSF    03.5
0520:  MOVWF  3D
0521:  BCF    03.5
0522:  MOVF   46,W
0523:  BSF    03.5
0524:  MOVWF  3C
0525:  BCF    03.5
0526:  MOVF   45,W
0527:  BSF    03.5
0528:  MOVWF  3B
0529:  BCF    03.5
052A:  MOVF   44,W
052B:  BSF    03.5
052C:  MOVWF  3A
052D:  BCF    03.5
052E:  MOVF   53,W
052F:  BSF    03.5
0530:  MOVWF  41
0531:  BCF    03.5
0532:  MOVF   52,W
0533:  BSF    03.5
0534:  MOVWF  40
0535:  BCF    03.5
0536:  MOVF   51,W
0537:  BSF    03.5
0538:  MOVWF  3F
0539:  BCF    03.5
053A:  MOVF   50,W
053B:  BSF    03.5
053C:  MOVWF  3E
053D:  BCF    03.5
053E:  CALL   14D
053F:  BCF    03.1
0540:  MOVF   63,W
0541:  BSF    03.5
0542:  MOVWF  3D
0543:  BCF    03.5
0544:  MOVF   62,W
0545:  BSF    03.5
0546:  MOVWF  3C
0547:  BCF    03.5
0548:  MOVF   61,W
0549:  BSF    03.5
054A:  MOVWF  3B
054B:  BCF    03.5
054C:  MOVF   60,W
054D:  BSF    03.5
054E:  MOVWF  3A
054F:  MOVF   7A,W
0550:  MOVWF  41
0551:  MOVF   79,W
0552:  MOVWF  40
0553:  MOVF   78,W
0554:  MOVWF  3F
0555:  MOVF   77,W
0556:  MOVWF  3E
0557:  BCF    03.5
0558:  CALL   1C4
0559:  MOVF   7A,W
055A:  BSF    03.5
055B:  MOVWF  39
055C:  MOVF   79,W
055D:  MOVWF  38
055E:  MOVF   78,W
055F:  MOVWF  37
0560:  MOVF   77,W
0561:  MOVWF  36
0562:  BCF    03.5
0563:  MOVF   4B,W
0564:  BSF    03.5
0565:  MOVWF  3D
0566:  BCF    03.5
0567:  MOVF   4A,W
0568:  BSF    03.5
0569:  MOVWF  3C
056A:  BCF    03.5
056B:  MOVF   49,W
056C:  BSF    03.5
056D:  MOVWF  3B
056E:  BCF    03.5
056F:  MOVF   48,W
0570:  BSF    03.5
0571:  MOVWF  3A
0572:  BCF    03.5
0573:  MOVF   57,W
0574:  BSF    03.5
0575:  MOVWF  41
0576:  BCF    03.5
0577:  MOVF   56,W
0578:  BSF    03.5
0579:  MOVWF  40
057A:  BCF    03.5
057B:  MOVF   55,W
057C:  BSF    03.5
057D:  MOVWF  3F
057E:  BCF    03.5
057F:  MOVF   54,W
0580:  BSF    03.5
0581:  MOVWF  3E
0582:  BCF    03.5
0583:  CALL   14D
0584:  BCF    03.1
0585:  BSF    03.5
0586:  MOVF   39,W
0587:  MOVWF  3D
0588:  MOVF   38,W
0589:  MOVWF  3C
058A:  MOVF   37,W
058B:  MOVWF  3B
058C:  MOVF   36,W
058D:  MOVWF  3A
058E:  MOVF   7A,W
058F:  MOVWF  41
0590:  MOVF   79,W
0591:  MOVWF  40
0592:  MOVF   78,W
0593:  MOVWF  3F
0594:  MOVF   77,W
0595:  MOVWF  3E
0596:  BCF    03.5
0597:  CALL   1C4
0598:  MOVF   7A,W
0599:  BSF    03.5
059A:  MOVWF  39
059B:  MOVF   79,W
059C:  MOVWF  38
059D:  MOVF   78,W
059E:  MOVWF  37
059F:  MOVF   77,W
05A0:  MOVWF  36
05A1:  BCF    03.5
05A2:  MOVF   4F,W
05A3:  BSF    03.5
05A4:  MOVWF  3D
05A5:  BCF    03.5
05A6:  MOVF   4E,W
05A7:  BSF    03.5
05A8:  MOVWF  3C
05A9:  BCF    03.5
05AA:  MOVF   4D,W
05AB:  BSF    03.5
05AC:  MOVWF  3B
05AD:  BCF    03.5
05AE:  MOVF   4C,W
05AF:  BSF    03.5
05B0:  MOVWF  3A
05B1:  BCF    03.5
05B2:  MOVF   5B,W
05B3:  BSF    03.5
05B4:  MOVWF  41
05B5:  BCF    03.5
05B6:  MOVF   5A,W
05B7:  BSF    03.5
05B8:  MOVWF  40
05B9:  BCF    03.5
05BA:  MOVF   59,W
05BB:  BSF    03.5
05BC:  MOVWF  3F
05BD:  BCF    03.5
05BE:  MOVF   58,W
05BF:  BSF    03.5
05C0:  MOVWF  3E
05C1:  BCF    03.5
05C2:  CALL   14D
05C3:  BCF    03.1
05C4:  BSF    03.5
05C5:  MOVF   39,W
05C6:  MOVWF  3D
05C7:  MOVF   38,W
05C8:  MOVWF  3C
05C9:  MOVF   37,W
05CA:  MOVWF  3B
05CB:  MOVF   36,W
05CC:  MOVWF  3A
05CD:  MOVF   7A,W
05CE:  MOVWF  41
05CF:  MOVF   79,W
05D0:  MOVWF  40
05D1:  MOVF   78,W
05D2:  MOVWF  3F
05D3:  MOVF   77,W
05D4:  MOVWF  3E
05D5:  BCF    03.5
05D6:  CALL   1C4
05D7:  MOVF   7A,W
05D8:  MOVWF  5F
05D9:  MOVF   79,W
05DA:  MOVWF  5E
05DB:  MOVF   78,W
05DC:  MOVWF  5D
05DD:  MOVF   77,W
05DE:  MOVWF  5C
.................... u1=u; 
05DF:  MOVF   5F,W
05E0:  MOVWF  63
05E1:  MOVF   5E,W
05E2:  MOVWF  62
05E3:  MOVF   5D,W
05E4:  MOVWF  61
05E5:  MOVF   5C,W
05E6:  MOVWF  60
.................... e2=e1; 
05E7:  MOVF   57,W
05E8:  MOVWF  5B
05E9:  MOVF   56,W
05EA:  MOVWF  5A
05EB:  MOVF   55,W
05EC:  MOVWF  59
05ED:  MOVF   54,W
05EE:  MOVWF  58
.................... e1=e; 
05EF:  MOVF   53,W
05F0:  MOVWF  57
05F1:  MOVF   52,W
05F2:  MOVWF  56
05F3:  MOVF   51,W
05F4:  MOVWF  55
05F5:  MOVF   50,W
05F6:  MOVWF  54
.................... if(u<=0) 
05F7:  MOVF   5F,W
05F8:  BSF    03.5
05F9:  MOVWF  39
05FA:  BCF    03.5
05FB:  MOVF   5E,W
05FC:  BSF    03.5
05FD:  MOVWF  38
05FE:  BCF    03.5
05FF:  MOVF   5D,W
0600:  BSF    03.5
0601:  MOVWF  37
0602:  BCF    03.5
0603:  MOVF   5C,W
0604:  BSF    03.5
0605:  MOVWF  36
0606:  CLRF   3D
0607:  CLRF   3C
0608:  CLRF   3B
0609:  CLRF   3A
060A:  BCF    03.5
060B:  CALL   30A
060C:  BTFSC  03.0
060D:  GOTO   610
060E:  BTFSS  03.2
060F:  GOTO   612
.................... { 
.................... do_rong_xung=0; 
0610:  CLRF   64
.................... } 
0611:  GOTO   675
.................... else if(u>=12) 
0612:  BSF    03.5
0613:  CLRF   39
0614:  CLRF   38
0615:  MOVLW  40
0616:  MOVWF  37
0617:  MOVLW  82
0618:  MOVWF  36
0619:  BCF    03.5
061A:  MOVF   5F,W
061B:  BSF    03.5
061C:  MOVWF  3D
061D:  BCF    03.5
061E:  MOVF   5E,W
061F:  BSF    03.5
0620:  MOVWF  3C
0621:  BCF    03.5
0622:  MOVF   5D,W
0623:  BSF    03.5
0624:  MOVWF  3B
0625:  BCF    03.5
0626:  MOVF   5C,W
0627:  BSF    03.5
0628:  MOVWF  3A
0629:  BCF    03.5
062A:  CALL   30A
062B:  BTFSC  03.0
062C:  GOTO   62F
062D:  BTFSS  03.2
062E:  GOTO   632
.................... { 
.................... do_rong_xung=251; 
062F:  MOVLW  FB
0630:  MOVWF  64
.................... } 
0631:  GOTO   675
.................... else 
.................... { 
.................... do_rong_xung=(int8)(u*20.833); 
0632:  MOVF   5F,W
0633:  BSF    03.5
0634:  MOVWF  3D
0635:  BCF    03.5
0636:  MOVF   5E,W
0637:  BSF    03.5
0638:  MOVWF  3C
0639:  BCF    03.5
063A:  MOVF   5D,W
063B:  BSF    03.5
063C:  MOVWF  3B
063D:  BCF    03.5
063E:  MOVF   5C,W
063F:  BSF    03.5
0640:  MOVWF  3A
0641:  MOVLW  FC
0642:  MOVWF  41
0643:  MOVLW  A9
0644:  MOVWF  40
0645:  MOVLW  26
0646:  MOVWF  3F
0647:  MOVLW  83
0648:  MOVWF  3E
0649:  BCF    03.5
064A:  CALL   14D
064B:  MOVF   7A,W
064C:  BSF    03.5
064D:  MOVWF  39
064E:  MOVF   79,W
064F:  MOVWF  38
0650:  MOVF   78,W
0651:  MOVWF  37
0652:  MOVF   77,W
0653:  MOVWF  36
*
0672:  MOVF   78,W
0673:  BCF    03.5
0674:  MOVWF  64
.................... } 
.................... set_pwm1_duty(do_rong_xung); 
0675:  MOVF   64,W
0676:  MOVWF  15
.................... a=0; 
0677:  CLRF   2E
.................... time=0; 
0678:  CLRF   30
0679:  CLRF   2F
.................... } 
.................... } 
....................  
....................  
067A:  BCF    0B.2
067B:  BCF    0A.3
067C:  BCF    0A.4
067D:  GOTO   025
.................... #INT_CCP2 
.................... void ngat_CCP2() 
.................... { 
.................... a=a+1; 
067E:  MOVLW  01
067F:  ADDWF  2E,F
0680:  BCF    0D.0
0681:  BCF    0A.3
0682:  BCF    0A.4
0683:  GOTO   025
.................... } 
....................  
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  BSF    03.5
0804:  BSF    03.6
0805:  BCF    07.3
0806:  MOVLW  0C
0807:  BCF    03.6
0808:  MOVWF  19
0809:  MOVLW  A2
080A:  MOVWF  18
080B:  MOVLW  90
080C:  BCF    03.5
080D:  MOVWF  18
080E:  CLRF   2E
080F:  CLRF   30
0810:  CLRF   2F
0811:  CLRF   33
0812:  CLRF   57
0813:  CLRF   56
0814:  CLRF   55
0815:  CLRF   54
0816:  CLRF   5B
0817:  CLRF   5A
0818:  CLRF   59
0819:  CLRF   58
081A:  CLRF   63
081B:  CLRF   62
081C:  CLRF   61
081D:  CLRF   60
081E:  CLRF   71
081F:  CLRF   70
0820:  MOVLW  FF
0821:  MOVWF  72
0822:  BSF    03.5
0823:  BSF    03.6
0824:  MOVF   09,W
0825:  ANDLW  C0
0826:  MOVWF  09
0827:  BCF    03.6
0828:  BCF    1F.4
0829:  BCF    1F.5
082A:  MOVLW  00
082B:  BSF    03.6
082C:  MOVWF  08
082D:  BCF    03.5
082E:  CLRF   07
082F:  CLRF   08
0830:  CLRF   09
0831:  BCF    03.7
....................  { 
....................  LCD_Init(); 
*
0835:  BCF    0A.3
0836:  GOTO   684
0837:  BSF    0A.3
....................    
....................  Kp=0.1;//Chi su dung khau Kp=0.05,khong dung Ki va Kd. 
0838:  MOVLW  CD
0839:  MOVWF  37
083A:  MOVLW  CC
083B:  MOVWF  36
083C:  MOVLW  4C
083D:  MOVWF  35
083E:  MOVLW  7B
083F:  MOVWF  34
....................  Ki=0.000084; 
0840:  MOVLW  28
0841:  MOVWF  3B
0842:  MOVLW  29
0843:  MOVWF  3A
0844:  MOVLW  30
0845:  MOVWF  39
0846:  MOVLW  71
0847:  MOVWF  38
....................  Kd=0.1; 
0848:  MOVLW  CD
0849:  MOVWF  3F
084A:  MOVLW  CC
084B:  MOVWF  3E
084C:  MOVLW  4C
084D:  MOVWF  3D
084E:  MOVLW  7B
084F:  MOVWF  3C
....................  T=0.1; 
0850:  MOVLW  CD
0851:  MOVWF  43
0852:  MOVLW  CC
0853:  MOVWF  42
0854:  MOVLW  4C
0855:  MOVWF  41
0856:  MOVLW  7B
0857:  MOVWF  40
0858:  CLRF   27
0859:  BTFSC  0B.7
085A:  BSF    27.7
085B:  BCF    0B.7
....................  a0=Kp+(Ki*T)/2+Kd/T; 
085C:  MOVF   3B,W
085D:  BSF    03.5
085E:  MOVWF  3D
085F:  BCF    03.5
0860:  MOVF   3A,W
0861:  BSF    03.5
0862:  MOVWF  3C
0863:  BCF    03.5
0864:  MOVF   39,W
0865:  BSF    03.5
0866:  MOVWF  3B
0867:  BCF    03.5
0868:  MOVF   38,W
0869:  BSF    03.5
086A:  MOVWF  3A
086B:  BCF    03.5
086C:  MOVF   43,W
086D:  BSF    03.5
086E:  MOVWF  41
086F:  BCF    03.5
0870:  MOVF   42,W
0871:  BSF    03.5
0872:  MOVWF  40
0873:  BCF    03.5
0874:  MOVF   41,W
0875:  BSF    03.5
0876:  MOVWF  3F
0877:  BCF    03.5
0878:  MOVF   40,W
0879:  BSF    03.5
087A:  MOVWF  3E
087B:  BCF    0A.3
087C:  BCF    03.5
087D:  CALL   14D
087E:  BSF    0A.3
087F:  BTFSC  27.7
0880:  BSF    0B.7
0881:  MOVF   7A,W
0882:  BSF    03.5
0883:  MOVWF  23
0884:  MOVF   79,W
0885:  MOVWF  22
0886:  MOVF   78,W
0887:  MOVWF  21
0888:  MOVF   77,W
0889:  MOVWF  20
088A:  MOVF   23,W
088B:  MOVWF  2B
088C:  MOVF   22,W
088D:  MOVWF  2A
088E:  MOVF   21,W
088F:  MOVWF  29
0890:  MOVF   20,W
0891:  MOVWF  28
0892:  CLRF   2F
0893:  CLRF   2E
0894:  CLRF   2D
0895:  MOVLW  80
0896:  MOVWF  2C
0897:  BCF    0A.3
0898:  BCF    03.5
0899:  CALL   6FD
089A:  BSF    0A.3
089B:  BCF    03.1
089C:  CLRF   27
089D:  BTFSC  0B.7
089E:  BSF    27.7
089F:  BCF    0B.7
08A0:  MOVF   37,W
08A1:  BSF    03.5
08A2:  MOVWF  3D
08A3:  BCF    03.5
08A4:  MOVF   36,W
08A5:  BSF    03.5
08A6:  MOVWF  3C
08A7:  BCF    03.5
08A8:  MOVF   35,W
08A9:  BSF    03.5
08AA:  MOVWF  3B
08AB:  BCF    03.5
08AC:  MOVF   34,W
08AD:  BSF    03.5
08AE:  MOVWF  3A
08AF:  MOVF   7A,W
08B0:  MOVWF  41
08B1:  MOVF   79,W
08B2:  MOVWF  40
08B3:  MOVF   78,W
08B4:  MOVWF  3F
08B5:  MOVF   77,W
08B6:  MOVWF  3E
08B7:  BCF    0A.3
08B8:  BCF    03.5
08B9:  CALL   1C4
08BA:  BSF    0A.3
08BB:  BTFSC  27.7
08BC:  BSF    0B.7
08BD:  MOVF   7A,W
08BE:  BSF    03.5
08BF:  MOVWF  23
08C0:  MOVF   79,W
08C1:  MOVWF  22
08C2:  MOVF   78,W
08C3:  MOVWF  21
08C4:  MOVF   77,W
08C5:  MOVWF  20
08C6:  BCF    03.5
08C7:  MOVF   3F,W
08C8:  BSF    03.5
08C9:  MOVWF  2B
08CA:  BCF    03.5
08CB:  MOVF   3E,W
08CC:  BSF    03.5
08CD:  MOVWF  2A
08CE:  BCF    03.5
08CF:  MOVF   3D,W
08D0:  BSF    03.5
08D1:  MOVWF  29
08D2:  BCF    03.5
08D3:  MOVF   3C,W
08D4:  BSF    03.5
08D5:  MOVWF  28
08D6:  BCF    03.5
08D7:  MOVF   43,W
08D8:  BSF    03.5
08D9:  MOVWF  2F
08DA:  BCF    03.5
08DB:  MOVF   42,W
08DC:  BSF    03.5
08DD:  MOVWF  2E
08DE:  BCF    03.5
08DF:  MOVF   41,W
08E0:  BSF    03.5
08E1:  MOVWF  2D
08E2:  BCF    03.5
08E3:  MOVF   40,W
08E4:  BSF    03.5
08E5:  MOVWF  2C
08E6:  BCF    0A.3
08E7:  BCF    03.5
08E8:  CALL   6FD
08E9:  BSF    0A.3
08EA:  BCF    03.1
08EB:  CLRF   27
08EC:  BTFSC  0B.7
08ED:  BSF    27.7
08EE:  BCF    0B.7
08EF:  BSF    03.5
08F0:  MOVF   23,W
08F1:  MOVWF  3D
08F2:  MOVF   22,W
08F3:  MOVWF  3C
08F4:  MOVF   21,W
08F5:  MOVWF  3B
08F6:  MOVF   20,W
08F7:  MOVWF  3A
08F8:  MOVF   7A,W
08F9:  MOVWF  41
08FA:  MOVF   79,W
08FB:  MOVWF  40
08FC:  MOVF   78,W
08FD:  MOVWF  3F
08FE:  MOVF   77,W
08FF:  MOVWF  3E
0900:  BCF    0A.3
0901:  BCF    03.5
0902:  CALL   1C4
0903:  BSF    0A.3
0904:  BTFSC  27.7
0905:  BSF    0B.7
0906:  MOVF   7A,W
0907:  MOVWF  47
0908:  MOVF   79,W
0909:  MOVWF  46
090A:  MOVF   78,W
090B:  MOVWF  45
090C:  MOVF   77,W
090D:  MOVWF  44
....................  a1=-Kp+(Ki*T)/2-(2*Kd)/T; 
090E:  MOVF   34,W
090F:  BSF    03.5
0910:  MOVWF  20
0911:  BCF    03.5
0912:  MOVF   35,W
0913:  XORLW  80
0914:  BSF    03.5
0915:  MOVWF  21
0916:  BCF    03.5
0917:  MOVF   36,W
0918:  BSF    03.5
0919:  MOVWF  22
091A:  BCF    03.5
091B:  MOVF   37,W
091C:  BSF    03.5
091D:  MOVWF  23
091E:  BCF    03.5
091F:  CLRF   27
0920:  BTFSC  0B.7
0921:  BSF    27.7
0922:  BCF    0B.7
0923:  MOVF   3B,W
0924:  BSF    03.5
0925:  MOVWF  3D
0926:  BCF    03.5
0927:  MOVF   3A,W
0928:  BSF    03.5
0929:  MOVWF  3C
092A:  BCF    03.5
092B:  MOVF   39,W
092C:  BSF    03.5
092D:  MOVWF  3B
092E:  BCF    03.5
092F:  MOVF   38,W
0930:  BSF    03.5
0931:  MOVWF  3A
0932:  BCF    03.5
0933:  MOVF   43,W
0934:  BSF    03.5
0935:  MOVWF  41
0936:  BCF    03.5
0937:  MOVF   42,W
0938:  BSF    03.5
0939:  MOVWF  40
093A:  BCF    03.5
093B:  MOVF   41,W
093C:  BSF    03.5
093D:  MOVWF  3F
093E:  BCF    03.5
093F:  MOVF   40,W
0940:  BSF    03.5
0941:  MOVWF  3E
0942:  BCF    0A.3
0943:  BCF    03.5
0944:  CALL   14D
0945:  BSF    0A.3
0946:  BTFSC  27.7
0947:  BSF    0B.7
0948:  MOVF   7A,W
0949:  BSF    03.5
094A:  MOVWF  27
094B:  MOVF   79,W
094C:  MOVWF  26
094D:  MOVF   78,W
094E:  MOVWF  25
094F:  MOVF   77,W
0950:  MOVWF  24
0951:  MOVF   27,W
0952:  MOVWF  2B
0953:  MOVF   26,W
0954:  MOVWF  2A
0955:  MOVF   25,W
0956:  MOVWF  29
0957:  MOVF   24,W
0958:  MOVWF  28
0959:  CLRF   2F
095A:  CLRF   2E
095B:  CLRF   2D
095C:  MOVLW  80
095D:  MOVWF  2C
095E:  BCF    0A.3
095F:  BCF    03.5
0960:  CALL   6FD
0961:  BSF    0A.3
0962:  BCF    03.1
0963:  CLRF   27
0964:  BTFSC  0B.7
0965:  BSF    27.7
0966:  BCF    0B.7
0967:  BSF    03.5
0968:  MOVF   23,W
0969:  MOVWF  3D
096A:  MOVF   22,W
096B:  MOVWF  3C
096C:  MOVF   21,W
096D:  MOVWF  3B
096E:  MOVF   20,W
096F:  MOVWF  3A
0970:  MOVF   7A,W
0971:  MOVWF  41
0972:  MOVF   79,W
0973:  MOVWF  40
0974:  MOVF   78,W
0975:  MOVWF  3F
0976:  MOVF   77,W
0977:  MOVWF  3E
0978:  BCF    0A.3
0979:  BCF    03.5
097A:  CALL   1C4
097B:  BSF    0A.3
097C:  BTFSC  27.7
097D:  BSF    0B.7
097E:  MOVF   7A,W
097F:  BSF    03.5
0980:  MOVWF  23
0981:  MOVF   79,W
0982:  MOVWF  22
0983:  MOVF   78,W
0984:  MOVWF  21
0985:  MOVF   77,W
0986:  MOVWF  20
0987:  BCF    03.5
0988:  CLRF   27
0989:  BTFSC  0B.7
098A:  BSF    27.7
098B:  BCF    0B.7
098C:  BSF    03.5
098D:  CLRF   3D
098E:  CLRF   3C
098F:  CLRF   3B
0990:  MOVLW  80
0991:  MOVWF  3A
0992:  BCF    03.5
0993:  MOVF   3F,W
0994:  BSF    03.5
0995:  MOVWF  41
0996:  BCF    03.5
0997:  MOVF   3E,W
0998:  BSF    03.5
0999:  MOVWF  40
099A:  BCF    03.5
099B:  MOVF   3D,W
099C:  BSF    03.5
099D:  MOVWF  3F
099E:  BCF    03.5
099F:  MOVF   3C,W
09A0:  BSF    03.5
09A1:  MOVWF  3E
09A2:  BCF    0A.3
09A3:  BCF    03.5
09A4:  CALL   14D
09A5:  BSF    0A.3
09A6:  BTFSC  27.7
09A7:  BSF    0B.7
09A8:  MOVF   7A,W
09A9:  BSF    03.5
09AA:  MOVWF  27
09AB:  MOVF   79,W
09AC:  MOVWF  26
09AD:  MOVF   78,W
09AE:  MOVWF  25
09AF:  MOVF   77,W
09B0:  MOVWF  24
09B1:  MOVF   27,W
09B2:  MOVWF  2B
09B3:  MOVF   26,W
09B4:  MOVWF  2A
09B5:  MOVF   25,W
09B6:  MOVWF  29
09B7:  MOVF   24,W
09B8:  MOVWF  28
09B9:  BCF    03.5
09BA:  MOVF   43,W
09BB:  BSF    03.5
09BC:  MOVWF  2F
09BD:  BCF    03.5
09BE:  MOVF   42,W
09BF:  BSF    03.5
09C0:  MOVWF  2E
09C1:  BCF    03.5
09C2:  MOVF   41,W
09C3:  BSF    03.5
09C4:  MOVWF  2D
09C5:  BCF    03.5
09C6:  MOVF   40,W
09C7:  BSF    03.5
09C8:  MOVWF  2C
09C9:  BCF    0A.3
09CA:  BCF    03.5
09CB:  CALL   6FD
09CC:  BSF    0A.3
09CD:  BSF    03.1
09CE:  CLRF   27
09CF:  BTFSC  0B.7
09D0:  BSF    27.7
09D1:  BCF    0B.7
09D2:  BSF    03.5
09D3:  MOVF   23,W
09D4:  MOVWF  3D
09D5:  MOVF   22,W
09D6:  MOVWF  3C
09D7:  MOVF   21,W
09D8:  MOVWF  3B
09D9:  MOVF   20,W
09DA:  MOVWF  3A
09DB:  MOVF   7A,W
09DC:  MOVWF  41
09DD:  MOVF   79,W
09DE:  MOVWF  40
09DF:  MOVF   78,W
09E0:  MOVWF  3F
09E1:  MOVF   77,W
09E2:  MOVWF  3E
09E3:  BCF    0A.3
09E4:  BCF    03.5
09E5:  CALL   1C4
09E6:  BSF    0A.3
09E7:  BTFSC  27.7
09E8:  BSF    0B.7
09E9:  MOVF   7A,W
09EA:  MOVWF  4B
09EB:  MOVF   79,W
09EC:  MOVWF  4A
09ED:  MOVF   78,W
09EE:  MOVWF  49
09EF:  MOVF   77,W
09F0:  MOVWF  48
....................  a2=Kd/T; 
09F1:  MOVF   3F,W
09F2:  BSF    03.5
09F3:  MOVWF  2B
09F4:  BCF    03.5
09F5:  MOVF   3E,W
09F6:  BSF    03.5
09F7:  MOVWF  2A
09F8:  BCF    03.5
09F9:  MOVF   3D,W
09FA:  BSF    03.5
09FB:  MOVWF  29
09FC:  BCF    03.5
09FD:  MOVF   3C,W
09FE:  BSF    03.5
09FF:  MOVWF  28
0A00:  BCF    03.5
0A01:  MOVF   43,W
0A02:  BSF    03.5
0A03:  MOVWF  2F
0A04:  BCF    03.5
0A05:  MOVF   42,W
0A06:  BSF    03.5
0A07:  MOVWF  2E
0A08:  BCF    03.5
0A09:  MOVF   41,W
0A0A:  BSF    03.5
0A0B:  MOVWF  2D
0A0C:  BCF    03.5
0A0D:  MOVF   40,W
0A0E:  BSF    03.5
0A0F:  MOVWF  2C
0A10:  BCF    0A.3
0A11:  BCF    03.5
0A12:  CALL   6FD
0A13:  BSF    0A.3
0A14:  MOVF   7A,W
0A15:  MOVWF  4F
0A16:  MOVF   79,W
0A17:  MOVWF  4E
0A18:  MOVF   78,W
0A19:  MOVWF  4D
0A1A:  MOVF   77,W
0A1B:  MOVWF  4C
....................  setup_ccp1(CCP_PWM); 
0A1C:  BCF    72.2
0A1D:  MOVF   72,W
0A1E:  BSF    03.5
0A1F:  MOVWF  07
0A20:  BCF    03.5
0A21:  BCF    07.2
0A22:  MOVLW  0C
0A23:  MOVWF  17
0A24:  BSF    03.5
0A25:  CLRF   1B
0A26:  CLRF   1C
0A27:  MOVLW  01
0A28:  MOVWF  1D
....................  setup_ccp2(CCP_CAPTURE_RE);//  CCP_CAPTURE_DIV_1 
0A29:  BSF    72.1
0A2A:  MOVF   72,W
0A2B:  MOVWF  07
0A2C:  BCF    03.5
0A2D:  CLRF   1D
0A2E:  MOVLW  05
0A2F:  MOVWF  1D
....................  setup_timer_2(t2_div_by_16,250,1); //tan so xung f=1,245 kHz 
0A30:  MOVLW  00
0A31:  MOVWF  78
0A32:  IORLW  06
0A33:  MOVWF  12
0A34:  MOVLW  FA
0A35:  BSF    03.5
0A36:  MOVWF  12
....................  set_pwm1_duty(0); 
0A37:  BCF    03.5
0A38:  CLRF   15
....................  setup_timer_0(RTCC_INTERNAL|RTCC_DIV_16); // ngat sau 2.04 ms 
0A39:  BSF    03.5
0A3A:  MOVF   01,W
0A3B:  ANDLW  C0
0A3C:  IORLW  03
0A3D:  MOVWF  01
....................  //set_timer0(255); // 
....................  enable_interrupts(INT_EXT); 
0A3E:  BCF    03.5
0A3F:  BSF    0B.4
....................  ext_int_edge( H_TO_L );   // Sets up EXT 
0A40:  BSF    03.5
0A41:  BCF    01.6
....................  enable_interrupts(GLOBAL); 
0A42:  MOVLW  C0
0A43:  BCF    03.5
0A44:  IORWF  0B,F
....................  
.................... while(true) 
....................     {   
....................     ; 
0A45:  GOTO   245
....................     } 
....................  } 
0A46:  SLEEP

Configuration Fuses:
   Word  1: 2CF2   HS NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
